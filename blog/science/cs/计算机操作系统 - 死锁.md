# 计算机操作系统 - 死锁

[toc]

## 1 死锁的必要条件

已独占资源且不可剥夺，又去申请新的独占资源，形成了闭合等待链。共4个条件：

- 互斥：请求或已占有的资源某一时刻只能为一个进程所有。
- 不剥夺：进程所占有的资源只能由进程主动释放。
- 请求并保持：在独占资源后，申请其它被占资源（保持占有已有的独占资源）。
- 循环等待：请求并保持形成了环状链。

注意，资源的这些属性通常是要求，而不是已具备的性质；也即，实际使用这些资源时，通常需要用某种同步工具（进程的同步工具）来满足这些要求；

### 1.1 互斥

即资源具有独占性；不能同时为多个进程访问；

互斥锁可以实现独占性。互斥锁同一个时间只能由一个进程持有。这要求每个进程都遵循先持有某个互斥锁，再使用某个资源的要求。

### 1.2 不剥夺

即进程在占有某个资源时，也同时只能由这个进程释放；

互斥锁可以实现不可剥夺性。互斥锁必须由对应的进程持有和释放。

### 1.3 请求并保持

一个进程持有了某个独占资源后，去请求另一个独占资源；也即必须至少尝试占有两个资源；

在互斥锁作为同步工具的情况下，死锁总是出现在拥有一把锁的情况下，去拥有另一把锁的时候；

### 1.4 循环等待

如果一个进程独占了资源A，尝试独占资源B，而另一个进程在独占资源B，尝试独占资源A。此时，对于任意一个进程，其请求的资源依赖于自身已经占有的资源的释放，因此便形成了死锁（循环等待）。

## 2 死锁预防

- 通过打破死锁的4个必要条件实现。
- 死锁预防是一种严格的方法（即需要更大的代价）。

### 2.1 打破请求并保持条件

在占有了独占资源的情况下，请求其它独占资源时，如果请求失败了（因为资源已经被占有了），则应释放所有已占用资源（当然，释放所有资源并不必要，但是这种方式更简单）。此即打破请求并保持条件；

以互斥锁为例，如果进程占有了一把互斥锁，在尝试占有第二把互斥锁时失败，则应释放已经占有的互斥锁，并等待一段时间，再次重试。

从依赖图的角度来看，这种方法避免了所有的一个进程依赖另一个进程的资源的情况（因为一旦一个进程去依赖另一个进程的资源，这个进程就会释放所有资源，相当于会从图上消失），也即动态的避免了图的交叉（静态上看，仍然会交叉）。

这种要求显然是比较严格的（因为涉及到释放已有资源）；

### 2.2 打破循环等待条件

所谓打破循环等待条件，即避免依赖成环；

- 将所有可能产生死锁的独占资源编号，进程在尝试占用资源时，必须遵守从大到小（或者从小到大）的顺序。这种方式从图的角度来说，如果将所有的资源按编号的顺序从左到右摆放，则依赖一定是从左到右（或者从右到左）的一个方向，这样能避免成环；
- 更为精细但是更复杂的方式是，将所有的进程独占的资源绘制到图上，并且将各个进程请求资源的顺序绘制为有向边。绘制结束后，检查这个图，如果没有成环，则不会产生死锁。给资源编号的方式是这种方法的一种特殊情况；

从程序设计的角度而言，给资源编号是一种更为直观的方式；

## 3 死锁避免

- 避免系统进入不安全状态；
- 安全状态：存在一个执行顺序，使得能以非死锁完成全部任务的状态。安全状态一定是非死锁状态，非安全状态不一定是死锁状态。非安全状态一定会转化为死锁状态。安全状态是比不死锁更严格的状态，死锁是比不安全更严格的状态。
- 安全性算法：银行家算法。若安全性算法通过，则一定存在一个安全序列；若系统处于安全性状态，则至少存在一个安全序列。若系统处于安全性状态，则安全性算法一定通过（注意安全性算法和安全性的等价关系）。

## 死锁预防和死锁避免的比较



## 4 死锁检测与解除

- 死锁后，检测并解决死锁。
- 资源分配图：进程指向资源表示请求，资源指向进程表示已分配。
- 死锁定理：在资源分配图中，找出所有能执行完成的进程并消去进程和连线。如果存在不能消去的连线，则存在死锁。S为死锁的条件是当且仅当S状态的资源分配图是不可完全简化的。
- 死锁解除：剥夺资源；撤销进程；进程回退。
