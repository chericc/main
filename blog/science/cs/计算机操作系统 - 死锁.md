# 计算机操作系统 - 死锁

[toc]

## 1 死锁的必要条件

已独占资源且不可剥夺，又去申请新的独占资源，形成了闭合等待链。共4个条件：

- 互斥：请求或已占有的资源某一时刻只能为一个进程所有。
- 不剥夺：进程所占有的资源只能由进程主动释放。
- 请求并保持：在独占资源后，申请其它被占资源（保持占有已有的独占资源）。
- 循环等待：请求并保持形成了环状链。

注意，资源的这些属性通常是要求，而不是已具备的性质；也即，实际使用这些资源时，通常需要用某种同步工具（进程的同步工具）来满足这些要求；

### 1.1 互斥

即资源具有独占性；不能同时为多个进程访问；

互斥锁可以实现独占性。互斥锁同一个时间只能由一个进程持有。这要求每个进程都遵循先持有某个互斥锁，再使用某个资源的要求。

### 1.2 不剥夺

即进程在占有某个资源时，也同时只能由这个进程释放；

互斥锁可以实现不可剥夺性。互斥锁必须由对应的进程持有和释放。

### 1.3 请求并保持

一个进程持有了某个独占资源后，去请求另一个独占资源；也即必须至少尝试占有两个资源；

在互斥锁作为同步工具的情况下，死锁总是出现在拥有一把锁的情况下，去拥有另一把锁的时候；

### 1.4 循环等待

如果一个进程独占了资源A，尝试独占资源B，而另一个进程在独占资源B，尝试独占资源A。此时，对于任意一个进程，其请求的资源依赖于自身已经占有的资源的释放，因此便形成了死锁（循环等待）。

## 2 死锁预防

- 通过打破死锁的4个必要条件实现。
- 死锁预防是一种严格的方法（即需要更大的代价）。

### 2.1 打破请求并保持条件

在占有了独占资源的情况下，请求其它独占资源时，如果请求失败了（因为资源已经被占有了），则应释放所有已占用资源（当然，释放所有资源并不必要，但是这种方式更简单）。此即打破请求并保持条件；

以互斥锁为例，如果进程占有了一把互斥锁，在尝试占有第二把互斥锁时失败，则应释放已经占有的互斥锁，并等待一段时间，再次重试。

从依赖图的角度来看，这种方法避免了所有的一个进程依赖另一个进程的资源的情况（因为一旦一个进程去依赖另一个进程的资源，这个进程就会释放所有资源，相当于会从图上消失），也即动态的避免了图的交叉（静态上看，仍然会交叉）。

这种要求显然是比较严格的（因为涉及到释放已有资源）；

### 2.2 打破循环等待条件

所谓打破循环等待条件，即避免依赖成环；

- 将所有可能产生死锁的独占资源编号，进程在尝试占用资源时，必须遵守从大到小（或者从小到大）的顺序。这种方式从图的角度来说，如果将所有的资源按编号的顺序从左到右摆放，则依赖一定是从左到右（或者从右到左）的一个方向，这样能避免成环；
- 更为精细但是更复杂的方式是，将所有的进程独占的资源绘制到图上，并且将各个进程请求资源的顺序绘制为有向边。绘制结束后，检查这个图，如果没有成环，则不会产生死锁。给资源编号的方式是这种方法的一种特殊情况；

从程序设计的角度而言，给资源编号是一种更为直观的方式；

## 3 死锁避免

- 避免系统进入不安全状态；
- 安全状态：存在一个执行顺序，使得能以非死锁完成全部任务的状态。安全状态一定是非死锁状态，非安全状态不一定是死锁状态。非安全状态一定会转化为死锁状态。安全状态是比不死锁更严格的状态，死锁是比不安全更严格的状态。
- 安全性算法：银行家算法。若安全性算法通过，则一定存在一个安全序列；若系统处于安全性状态，则至少存在一个安全序列。若系统处于安全性状态，则安全性算法一定通过（注意安全性算法和安全性的等价关系）。

## 死锁预防和死锁避免的比较

- 资源分配策略：死锁预防是保守的（只分配需要的资源），死锁避免是不保守的（可能会提前预留更多的资源）；
- 抢占：死锁预防存在抢占（比如正在抢占的负责解决死锁问题），死锁避免不会出现抢占（提前规划的路径是安全的）；
- 优点：死锁预防简单，成本低；死锁避免能充分利用系统资源；
- 缺点：死锁预防资源利用率低；死锁避免需要更多的信息；

## 4 死锁检测与解除

- 死锁后，检测并解决死锁。
- 资源分配图：进程指向资源表示请求，资源指向进程表示已分配。
- 死锁定理：在资源分配图中，找出所有能执行完成的进程并消去进程和连线。如果存在不能消去的连线，则存在死锁。S为死锁的条件是当且仅当S状态的资源分配图是不可完全简化的。
- 死锁解除：剥夺资源；撤销进程；进程回退。

## 死锁场景举例

### 模块层次问题引起的死锁

#### 场景说明

日志模块属于独立的模块，不应调用外部模块。如果日志模块调用了外部模块，就很容易引起一些问题。例如：

log --> util --> log，这个调用没有条件的情况下会引起反复递归，但是如果增加了递归条件则不会反复递归。现假设log调用util的条件为距离上次调用的时间达到1min。

- 场景1：（外部调用引起）log模块调用util模块（刚好1min时），util模块再次调用log模块，距离上次调用时间很近，不会递归调用；如果log本身没有锁，则正常，如果有锁，则锁死（在一个线程，不考虑递归锁的情况）；
- 场景2：外部调用util模块，util模块调用log模块，log模块再次调用util模块（刚好1min时），后续不会递归调用；如果util本身有锁，则锁死；

尽管用递归锁可以解决这个问题，但是这个问题的本质原因在于递归调用的存在。应该将模块设计为层次化的形式，避免递归调用的出现。

#### 分析方法

平台：Android

出现问题之后，不要继续输入避免触发ANR。

首先定位问题进程的PID，然后执行 debuggerd -b PID 。就得到了所有的线程的调用栈。

观察这些调用栈，可以发现很多的调用栈都是相似的位置卡住了，因此很大概率怀疑这里的锁被某个线程占用了没有释放，导致其它线程全部卡住了。

"TestTimer1" sysTid=3058
  #00 pc 00019d74  /system/lib/libc.so (syscall+28)
  #01 pc 0001d1dd  /system/lib/libc.so (__futex_wait_ex(void volatile*, bool, int, bool, timespec const*)+88)
  #02 pc 0006475d  /system/lib/libc.so (NonPI::MutexLockWithTimeout(pthread_mutex_internal_t*, bool, timespec const*)+156)
  #03 pc 0001bf8f  /system/lib/libfhUtils.so (FHPlayerProperty::getIntProperty(char const*, int)+22)
  #04 pc 00025107  /system/lib/libfhUtils.so (printf_log(int, char const*, char const*, std::__va_list&)+226)
  #05 pc 00025423  /system/lib/libfhUtils.so (FHPlayerLog::debug(char const*, char const*, ...)+54)
  #06 pc 0001bfeb  /system/lib/libfhUtils.so (FHPlayerProperty::getIntProperty(char const*, int)+114)
  #07 pc 00025107  /system/lib/libfhUtils.so (printf_log(int, char const*, char const*, std::__va_list&)+226)
  #08 pc 00025423  /system/lib/libfhUtils.so (FHPlayerLog::debug(char const*, char const*, ...)+54)
  #09 pc 0001aaa3  /system/lib/libfhNativePlayer.so (FHIptvPlayer::getPlayerId()+18)

同时，这里可以很容易发现，出现了递归调用。显然是有异常的。

### 一种涉及到类中线程对象析构和状态变量的死锁

#### 场景举例

类持有一个线程对象，线程对象会修改状态变量，类的析构函数也会修改状态变量；代码结构如下：

```c++

class Work {
public:
  ~Work() {
    AutoLock;
    State = Stopped;
    signal();
  }

  start() {
    trd.start([]() {
      State = Paused;

      while (true) {
        AutoLock;
        if (State == Stopped) {
          break;
        }
        if (State == Paused) {
          wait();
        }
        // do something.
      }
    });
  }
private:
  State = None;
  thread trd;
}

```

这段代码的意思是，如果线程创建后没有任务可做（处于暂停状态），则等待；析构时，先将状态置为停止状态，然后触发线程继续运行，并退出；

这段代码在压力测试中，会出现阻塞在析构函数中的问题；经分析，阻塞在析构函数执行之后，因此应为类对象的析构出现了异常。

#### 问题原因

存在一种情况，析构函数结束后（还没有执行线程对象的析构），线程开始运行，此时线程阻塞，但是没有外部的调用来激活（析构函数已经提前执行了），因此阻塞。

#### 问题分析

1. 对状态变量的修改放在了异步线程中，从而无法明确修改在何时发生。线程对象作为特殊的对象（存在不同的执行线），从设计上来讲，需要在析构函数中进行显式的回收（join）。如果进行显式的join，则必然需要考虑到线程退出的条件。

举例如下：

```c++
~Wrok() {
  while (true) {
    State = Stopped;
    signal();
    if (trd.timedJoin()) {
      break;
    }
    usleep(5);
  }
}
```

即，需要回收这个线程时，不断尝试去join线程，直到线程执行完毕。

2. 使用signal的时候，需要认识到其不能保证对应的wait函数一定会执行的情况。在本例中，signal时线程函数还在执行过程中，因此不会生效。

3. 多个线程同时使用同一个变量时，需要加锁。注：这个问题中，加锁并不能解决问题（出现问题时，是析构先执行，线程后执行）。这个问题可以通过把对状态变量的修改移动到线程外解决。此时，析构函数执行后，能确保wait部分的状态一定是退出状态，并且一定会执行（状态进行了加锁）。

注：另一个问题，**signal时能否不加锁？**

答：原理上可以，但是如果signal之前需要修改状态变量，就可能出现signal结束后，wait再执行，引起状态变量不会生效。