# call_once与锁

## 场景复现

有以下代码：

```c++
int *s_p = nullptr;

int* fun() {
    static std::once_flag once_flag{};
    std::call_once(once_flag, [&](){
        s_p = new int;
    });
    return s_p;
}
```

多线程环境下能否保证fun调用结束时得到的s_p一定不为空？

答案：不能。

## 原理

锁的原理是，获取锁后，所有对内存中的数据的修改一定会对所有线程可见。

这里的call_once只能保证，多个线程调用fun时，闭包只会执行一次，并且后续所有的调用都会等待这个闭包执行结束之后再执行。

即使这个闭包执行结束，但是其对全局变量s_p的写入并不一定对其它线程可见，因此其它线程调用时，有概率拿到一个空指针。这是这个问题的本质原因。

可以将s_p设置为原子变量，或者为s_p加一个全局锁解决这个问题。