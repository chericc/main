# C++ 并发编程实战

C++ Concurrency In Action

## 1 C++ 并发世界

### 1.1 什么是并发

#### 1.1.1 计算机系统中的并发

#### 1.1.2 并发的方式

##### 1.1.2.1 多进程并发

##### 1.1.2.2 多线程并发

#### 1.1.3 并发与并行

两个术语都是指使用可调配的硬件资源同时运行多个任务，但并行更强调性能。  

当人们谈及并行时，主要关心的是利用可调配的硬件资源提升大规模数据处理的性能；当谈及并发时，主要关心的是分离关注点或响应能力。  

### 1.2 为什么使用并发技术

应用软件使用并发技术的主要原因有两个：分离关注点与性能提升。  

#### 1.2.1 为分离关注点而使用并发

编写软件时，分离关注点几乎总是不错的构思：归类相关代码，隔离无关代码，使程序更易于理解和测试，因此所含缺陷很可能更少。  
并发技术可用于隔离不同领域的操作，即便这些操作需要同时进行。  

考虑一个 DVD 播放软件，其具有两大职责：首先是读取 DVD 数据，解码并传送给图形硬件和声音硬件；其次是接收用户输入。如果采用单一线程，则应用软件在播放过程中，不得不定时检查用户输入，结果会混杂播放 DVD 的代码与用户界面的代码。改用多线程既可以分离上述的两个关注点，一个线程只负责用户界面管理，另一个线程只负责播放 DVD，用户界面的代码和播放 DVD 的代码即可避免紧密纠缠。  

这样，线程的世纪数量便与 CPU 既有的内核数量无关，因为用线程分离关注点的依据是设计理念，不以增加吞吐量为目的。  

#### 1.2.2 为性能而并发：任务并行和数据并行

增强性能的并发方式有两种：第一种，最直观地，将单一任务分解成多个部分，各自并行运作，从而节省总运行耗时，这种方式即任务并行。任务分解可以针对处理过程，调度某线程运行同一算法的某部分，另一线程则运行其他部分；也可以针对数据，线程分别对数据的不同部分执行同样的操作，这被称为数据并行。  


易于采用上述并行方式的算法常常被称为尴尬并行算法。其含义是将算法的代码并行化非常简单。尴尬并行算法具备的优良特性是可按规模伸缩：只要硬件支持的线程数亩增加，算法的并行程度就能相应提升。

算法中除尴尬并行以外的部分，可以划分成一类，其并行任务的数目固定。  

第二种增强性能的兵法方式是利用并行资源解决规模更大的问题。例如，只要条件合适，便同时处理 2 个文件，或者更多个文件，而不是每次 1 个。采用这种方式处理单一数据所需的时间依旧不变，但同等时间内能处理的数据相对更多。  

#### 1.2.3 什么时候避免并发

- 编写正确运行的多线程代码需要额外的开发时间和相关维护成本，除非潜在的性能提升或分离关注点而提高的清晰度值得这些开销，否则不应该使用并发技术；  
- 性能增幅可能不及预期；  
- 线程是一种有限的资源，若一次运行太多的线程，便会消耗过多系统资源，可能令系统整体变慢（比如站在内存和地址空间的角度）；  
- 运行的线程越多，操作系统所做的上下文切换就越频繁，当线程的数目达到一定程度时，再增加新的线程反而会降低应用软件的整体性能；  

对于应用程序中设计性能的关键部分，若其具备提升性能的潜力，收效客观，才值得为之实现并发功能。  

如果首要目标是设计得清楚明晰或者分离关注点，而提升性能居次，也值得采用多线程设计。  

### 1.3 并发与 C++ 多线程

#### 1.3.1 C++ 多线程简史

#### 1.3.2 新标准对并发的支持

#### 1.3.3 C++14 和 C++17 进一步支持并发和并行

C++14 进一步增添了对并发和并行的支持，具体而言，是引入了一种用于保护共享数据的新互斥。C++17 则增添了一系列适合新手的并行算法函数。  

#### 1.3.4 标准 C++ 线程库的效率

若要实现某项功能，代码可以借助高级工具，或者直接使用底层工具。两种方式的运行开销不同，该项差异叫做抽象损失。  

在设计 C++ 标准库和标准 C++ 线程库时，其中一个设计目标是，嘉定某些代码采用了 C++ 标准库所提供的工具，如果改换为直接使用底层 API，应该不会带来性能增益，或者收效甚微。  

C++ 标准委员会的另一个目标是，确保 C++ 提供充足的底层工具来满足需求。为此，新标准带来了新的内存模型，以及全方位的原子操作库，其能直接单独操作每个位、每个字节，还能直接管控线程同步，并让线程之间可以看见数据变更。  

C++ 标准库还提供了高级工具，抽象程度更高，更易于编写多线程代码，出错机会更少。使用这些工具必须执行额外的代码，所以有时确实会增加性能开销，但这种性能开销不一定会引发更多抽象损失。与之相比，实现同样的功能，手动编写的代码所产生的开销往往更高。  

#### 1.3.5 平台专属的工具

### 1.4 启程之路

在一个新的线程中输出 hello world 。

```c1_1.cpp```

### 1.5 小结

## 2 线程管控

如果给定一个线程，只要令 std::thread 对象与之关联，就能管控该线程的几乎每个细节。对于复杂的任务，C++ 标准库还提供了基础构建单元以满足所需，我们可以灵活选择，直接使用。  

本章包括：发起线程；等待线程结束或者让线程在后台运行；在启动时向线程传递参数；将线程的归属权从某个 std::thread 对象转移给另一个；怎样选择合适数量的线程；怎样识别特定的线程。  

### 2.1 线程的基本管控

#### 2.1.1 发起线程

与 C++ 标准库中的许多类型相同，任何可调用类型都适用于 std::thread 。除了普通的函数外，我们还可以设计带有函数调用的类，并将该类的实例传递给 std::thread 的构造函数。  

值得注意的是，一个函数对象作为参数传递给 std::thread 时，它被复制到属于新线程的存储空间中，因此副本的行为必须和原本的函数对象等效，否则运行结果可能有违预期。  

将函数对象传递给 std::thread 的构造函数时，，还需要注意二义性问题。比如  

```
class task;
std::thread test(task());
```

其中 task 是一个可调用类，即一个类型。回顾函数指针的写法 ```typedef void(*func)()``` ，能发现 task() 就是一个函数指针类型。也即上述写法中 ```task()``` 既可以作为一个临时函数对象看，也可以作为一个函数指针类型看，整个语句也就因此可以视作构造一个线程对象，也可以视作声明一个参数类型为函数指针的函数。规避这个问题的一个简单方法就是使用初始化列表，即  

```
std::thread test{task()};
```

#### 2.1.2 等待线程完成

可以调用 std::thread 的成员函数 join() 实现等待。  

等待结束后，隶属于该线程的任何存储空间即会因此清除，std::thread 遂不再关联到已结束的线程。也即对于给定的线程，join() 只能调用一次。  

#### 2.1.3 在出现异常的情况下等待

需要注意一个线程如果没有 detach() ，则应该始终去 join() 。  

#### 2.1.4 在后台运行线程

调用 detach() 后，会令线程在后台运行，而无法直接与之通信。  

需要注意一个线程必须有与之关联的线程，也即必须 joinable() ，才能分离。  

#### 2.1.5 向线程函数传递参数

直接向 std::thread 的构造函数添加更多的参数即可。  

注意：std::thread 具有内部存储空间，参数会按照默认方式先复制到该处，新创建的执行线程才能直接访问它们。然后，这些副本被当成临时变量，以右值形式传给新线程上的函数或可调用对象。  

```
void f(std::string const& s);
void fun(int param)
{
    char buffer[1024];
    snprintf(buffer, sizeof(buffer), "%d", param);
    std::thread trd(f, buffer);
    trd.detach();
}
```

注意这段实现存在未定义的行为。构建线程对象时，buffer 作为一个指针传入，当线程实际执行的时候，才会去访问这个指针，而此时这个 buffer 可能已经失效了。解决这个问题的一个办法就是将 buffer 直接构造为一个 std::string 对象传入。  

当尝试通过线程参数传递引用时，也会存在一些问题，比如：  

```c++
void fun(int &t)
{
    t = 2;
    return ;
}

int main()
{
    int c = 0;

    std::thread thd(fun, c);
    thd.join();
    printf("c=%d\n", c);
    return 0;
}
```

只要将 fun 的参数改为非常引用的方式，编译就会报错（报错可能不容易分析）。其原因是线程库最终以右值的方式传递给线程函数。  
要解决这个问题，需要将引用包装（成一个可复制对象），即 std::ref(c) 。  

线程的参数支持移动语义。  

### 2.3 移交线程归属权

可以使用 std::move 移动线程，移动线程的实际语义是移动线程对象关联的线程。  

### 2.4 在运行时选择线程数量

使用 std::thread::hardware_concurrency() 可以获得可真正并发的线程数量。  

### 2.5 识别线程

两种方法：thread_obj.get_id() 或者 std::this_thread::get_id() 。  

## 3 在线程间共享数据



### 3.1 线程间共享数据的问题

多线程共享数据的问题多由数据改动引发。  

不变量：不变量是一个针对某一特定数据的断言，该断言总是成立的。例如，“这个变量的值即为链表中元素的数目”。  

不变量：invariant  

#### 3.1.1 条件竞争

在并发编程中，操作由两个或多个线程负责，它们争先让线程执行各自的操作，而结果取决于它们执行的相对次序，所有这种情况都是条件竞争。如果出现条件竞争后，所有的结果都可以接受，则是良性的条件竞争。条件竞争通常指恶性条件竞争。  
诱发恶性条件竞争的一个典型场景是，要完成一个操作，却需要改动两份或多份不同的数据。  

#### 3.1.2 防止恶性条件竞争

- 采取保护措施包装数据结构，确保不变量被破坏时，中间状态只对执行改动的线程可见。在其它访问同一数据的线程的视角中，这种改动要么尚未开始，要么已经完成；  
- 修改数据结构的设计及其不变量，由一连串不可拆分的改动完成数据结构变更，每个改动都维持不变量不被破坏。这种方法被称为无锁编程；  
- 将修改数据结构当作事务来处理，类似于数据库在一个事务内完成更新：把需要执行的数据读写操作视为一个完整的序列。这称为软件事务内存。C++ 没有直接支持。  

### 3.2 用互斥保护共享数据

互斥是 C++ 最通用的共享数据保护措施之一。  
互斥本身也有问题，表现形式是死锁、对数据的过保护或欠保护。  

#### 3.2.1 在 C++ 中使用互斥

std::mutex  

std::lock_guard<std::mutex> lock(mutex)

#### 3.2.2 组织和编排代码以保护共享数据

大多数场景下的普遍做法是，将互斥与受保护的数据组成一个类。这是面向对象设计准则的典型运用：将两者放在同一个类里，清楚表明它们相互联系，还能封装函数以增强保护。  

有两个需要注意的点：  

- 如果成员函数返回指针或引用，指向受保护的数据，则保护就会被打破。  
- 如果成员函数的实现中将受保护的数据的指针或引用传递给其他调用，而其他调用可能会将指针或引用暂存在某个位置，则保护也会被打破。  

#### 3.2.3 发现接口固有的条件竞争

尽管运用了互斥或其他方式保护共享数据，条件竞争仍然无法避免。  

比如，我们对于一个栈结构，在弹出元素时，存在 empty() 判断和 pop() 操作之间竞争的问题（有可能判断 empty 时有元素，但是 pop 时已空），或者获取元素，然后弹出一个元素，则取元素和弹出之间就存在竞争问题（获取的元素还没有被弹出，另一个线程就在获取，导致两者获取了同一个元素）。

这要求我们重新设计接口。  

对于 top 和 pop 的竞争问题，可以尝试将 top 和 pop 封装为一个成员函数，但是这种封装仍然存在问题，那就是不能确保异常安全（也正是这个原因，实际的栈才将这两个操作分开）。考虑我们的实现是先取出元素，然后将栈中的元素移除，最终向调用者返回被取出的元素。如果在向调用者返回元素的过程中出现了异常（比如内存不足），则复制不成功，但是实际数据已经丢失。所以不能通过合并操作的方式来解决竞争问题。  

几种避免方法：  

1. 传入引用

比如通过增加引用，合并 pop 和 top ，这样就能做到异常安全。但是由调用者提供一个实例，有时可能是代价很高的。  

2. 提供不抛出异常的拷贝构造或移动构造函数

这样就能通过限制异常达到不出现异常的目的，但同样增加了对调用者的额外需求。  

3. 返回指针，指向弹出的元素

指针的拷贝不会产生异常，std::shared_ptr 可以用来实现这个需求。  

线程安全的栈容器类：  

```c3_4.cpp```

仅保留 push 和 pop 操作。  

