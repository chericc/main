# heap

## 父节点、左右子节点的索引

堆是一颗完全二叉树，在本例中，不影响推断，将堆扩展为一棵满二叉树。

记树顶的层数为$0$，根节点索引值为$0$。从空的堆开始，每插入一个节点，其索引值加1。

另记第$j$层从左往右各个节点的序号为$s_j=\{0,1,2,...,2^{j}-1\}$，第$j+1$层相应为$s_{j+1}=\{0,1,...,2^{j+1}-1\}$。

第${j}$层的第一个节点索引值为$2^{j}$，最后一个节点的索引值为$2^{j} - 1 + 2^j=2^{j+1}-1$。

因此得到第$j$层的所有节点的索引值从左往右依次为$\{2^{j}-1, 2^{j}, ..., 2^{j} + 2^{j} - 2\}$。

对应的$j+1$层的所有节点的索引值从左往右依次为$\{2^{j+1}-1, 2^{j+1},...,2^{j+1}+2^{j+1}-2\}$。

由于两层是二叉对应关系，因此第$j$层的序号为$s_j$的左右子节点的序号为$2s_j$和$2s_j+1$，同样的，第$j+1$层的序号为$s_{j+1}$的父节点为$\lfloor s_{j+1}/2 \rfloor$。

若第$j$层的某个节点的索引值为$i$，序号为$s$，有$i=2^j + s - 1$。（根据左右子节点序号的关系）因此其左右子节点的索引值分别为$i_{left}=2^{j+1}+2s-1$和$i_{right}=2^{j+1}+2s$，其父节点的索引值为$i_{parent} = 2^{j-1} -1+ \lfloor s/2 \rfloor$。

可以验证，$i_{left}=i*2+1$，$i_{right}=i*2+2$，$i_{parent} = \lfloor (i-1)/2 \rfloor$成立。

## 维护堆的时间复杂度

对于一棵满树，最差的情况下，需要一直比较到叶节点，因此复杂度与树高相关。

先记堆维护时间为函数$T(n)$。

设树节点树为$n$，则维护堆时首先比较左右两个子节点，然后对其中一个子节点执行维护。子节点维护函数最大时即其节点数最大时。右子树设树高为$h$，则左子树树高为$h-1$，右子树为$h-2$，此时左子树的节点数是右子树的两倍，记左子树节点数为$a$，有$a+a/2+1=n$，即左子树的维护时间小于$T(2n/3)$。因此有递归式：

$$
T(n)\le T(2n/3)+\Theta(1)
$$

套用主定理$T(n)=aT(n/b)+f(n)$，有$a=1,b=3/2,f(n)=1$，则$\log_b a=0$，即满足情况2。故$T(n)=\Omicron(\lg n)$。

考虑$n=2^h$，即$h=\log_2 n$，即$T(n)=\lg n=\Omicron(h)$。

## 建堆的时间复杂度

对一个满堆建堆，设总数为$n$，则总共需要对前$n/2$个节点执行维护堆操作。

直观的看，需要对约$n/2$个节点执行$\Omicron(h)$的维护堆操作，因此总的时间复杂度应为$\Omicron(n\lg n)$。但是考虑到大多数靠近叶节点的节点树高很小，因此实际复杂度应更小。

令$2^0 + 2^1 + ... + 2^h = n$，即总的时间为$T(n)=2^0\times h + 2^1\times (h-1) + ... + 2^{h-1}\times 1=\sum_{i=0}^{h-1}2^i\times (h-i)$。

利用对等比数列和，$\sum_{x=0}^{n}r^x=\frac{r^{x+1}-1}{r-1}$，求导并取$r=2$，可以得到$\sum_{x=0}^{n}xr^x=(n-1)2^{n+1}+2$。

因此有$T(n)=h2^h-[(h-2)2^h+2]=2^{h+1}-2$，而$h=\log_2n$，因此$T(n)=\Omicron(n)$。

## 堆排序算法的复杂度

堆排序首先需要建堆，由于建堆的复杂度是$\Omicron(n)$，因此可以不考虑。

以未排序的节点为堆，每次维护堆时，层高较高对应的节点数较多，而层高较低时对应的节点数较少。这恰好和建堆的场景是相反的。

相似的，有$T(n)=\Omicron(2^h\times h+2^{h-1}\times (h-1) + ... + 2^0\times 0)=\Omicron(\sum_{i=0}^{h}2^i\times i)$。

直接套用公式，有$T(n)=\Omicron((h-1)2^{h+1}+2)=\Omicron(n\lg n)$。