# 第四部分 高级设计和分析技术

主要介绍三种重要结束：动态规划、贪心算法、摊还分析。

**动态规划**通常用来解决最优化问题，在这类问题中，我们通过做出一组选择来达到最优解。在做出选择的同时，通常会生成与原问题形式相同的子问题。当多于一个选择子集都生成相同的子问题时，动态规划技术通常就会很有效。动态规划的关键技术就是对每个子问题都保存解，当其重复出现时即可避免重复求解。

**贪心算法**通常最优化问题，我们做出一组选择来达到最优解。贪心算法的思想是每步选择都追求局部最优。贪心算法对许多问题都能求得最优解，而且速度比动态规划方法快得多，但是，我们并不能总能简单地判断出贪心算法是否有效。**拟阵理论**提供了相应的数学基础，可以帮助我们证明一个贪心算法生成最优解。

**摊还分析**用于分析一类特定的算法，这类算法执行一组相似的操作组成的序列。摊还分析并不是通过分别分析每个操作的实际代价的界来分析操作序列的代价的界，而是直接分析序列整体的实际代价的界。这个方法的一个好处是，虽然某些操作的代价可能很高，但其他很多操作的代价可能很低。摊还分析不仅仅是一种分析工具，它还是一种思考算法设计的方式。

## 第15章 动态规划

动态规划，Dynamic Programming。Programming这里指表格法。

动态规划和分治方法类似，都是通过组合子问题的解来求解原问题的。区别是分治方法将问题划分为互不相交的子问题，而动态规划则处理子问题重叠的情况。如果用分治法处理子问题重叠的情况，则会出现大量的重复计算。动态规划将子问题的解存储在表格中，从而每个重复的子问题只会计算一次。

### 15.1 钢条切割问题

**钢条切割问题**：给定一段长度为$n$的钢条和一个价格表$P=p_i(i\in [1,2,...,n])$，求切割方案，使得销售收益最大。

不妨假设存在某个最优方案，并且将整个切割过程看成是一步步进行的。将每次对整个钢条或更小的钢条的切割过程看成一个问题，则整个切割过程就是由多个子问题组成的。考虑到收益最大时，所有子问题的收益也最大（否则，就会存在更优的切割方案），这种问题的最优解由相关的子问题的最优解组合而成，并且每个子问题可以独立求解，称为**最优子结构**。

一个更为简单的方法是将钢条切割过程看成是从左至右的切割过程（最终切割的结果是没有顺序的，因此调整切割顺序不影响最终的解）。由于左边已经切割过的段不再进行切割，因此只需要考虑右侧的段是否需要切割。

记$r_n$为长度为$n$的钢条切割得到的最大收益，则切割收益为从最左侧切割一段得到的收益和剩下的钢条的最大收益，即$r_n=\max (r_{n-i} + p_i),i\in [1,n]$，其中，当$i$为$n$时，代表不切割。

#### 15.1.1 使用分治法求解

将钢条的切割过程特化为从左到右之后，整个切割过程可以看作从左侧选择一段，然后利用递归函数求解右侧的切割后的最大收益，计算两者之和作为当前切割方式的收益，并求选择哪一段的切割收益最大。

记计算收益的函数`price_rod`在处理长度为$n$的钢条时，被调用的次数为$T(n)$，显然有$T(0)=1$，$T(n)=1+\sum_{i=0}^{n-1}T(i)$，其中$1$表示表示递归调用的最上层调用。

由该递推公式可以得到，$T(n+1)=2T(n)$，也即有$T(n)=2^{n}$。

指数级的复杂度使得运算的规模扩张非常快，但是通过分析很容易看出来，在递归求解的过程中，大部分时间都浪费在对相同子问题的重复求解上。

#### 15.1.2 使用动态规划求解

在求解的过程中，将已经得到的子问题记录下来，后续在计算某个子问题时，先检查该子问题是否已经计算过，这样就可以避免大量的重复计算。

动态规划求解有两种方式，一种为自顶向下，一种为自底向上。前者即在分治求解的过程中，将计算过程中得到的结果存下来。后者即从小问题开始计算，逐步累积后再计算目标问题。

对于自底向上的计算方式，由于求解每个长度时，所有子长度的解均已知，因此总的求解次数为$1+2+3+...+n$，即时间复杂度为$\Theta(n^2)$。

对于自顶向下的计算方式，计算长度为$n$的长度时，会依赖长度为$n-1$、$n-2$、...、$1$的所有长度的解，每个子问题只会求解一次。由于长度为$n$时存在$n$个循环，因此总的次数是一个等差数列，即时间复杂度是$\Theta (n^2)$。

#### 15.1.3 子问题图

子问题图可以用来表示一个动态规划问题中的子问题以及子问题之间的依赖关系。

子问题图是一个有向图。每个顶点唯一地对应一个子问题。若子问题a的最优解需要用到子问题b的最优解，则子问题图中就会有一条从子问题a的顶点到子问题b的顶点的有向边。

子问题图$G=(V,E)$的规模可以帮助确定动态规划算法的运行时间。由于每个子问题只求解一次，因此算法运行时间等于每个子问题求解时间之和。通常情况下，一个子问题的求解时间和子问题图中对应顶点的度成正比，子问题的数目对应子问题图的顶点数目。因此，通常情况下，**动态规划算法的运行时间与顶点和边的数量呈线性关系**。

#### 15.1.4 重构解

通过对每个子问题保存最优收益值，同时保存对应的切割方案，就可以输出最优解。

### 15.2 矩阵链乘法

给定一个$n$个矩阵的序列（矩阵链），计算其乘积。由于矩阵的乘法满足结合律，因此任何加括号的方法都会得到相同的结果。

称具有如下性质的矩阵乘积链为**完全括号化**的：单一矩阵，或者是两个完全括号化的矩阵乘积链的积，且已外加括号。

对矩阵链加括号的方式会对矩阵乘积运算的复杂度产生巨大影响。将高度为$h$、宽度为$w$的矩阵表示为$[h,w]$，则$[a,b],[b,c]$两个矩阵相乘的运算复杂度为$\Theta (abc)$。以三个矩阵$[10,100],[100,5],[5,50]$为例，如果按先后顺序计算，则共有$10\times 100\times 5 + 10\times 5\times 50=7500$次乘法，如果先计算后两个矩阵乘法，则共有$100\times 5\times 50+10\times 100\times 50=75000$次乘法。后者的运算次数是前者的10倍。

**矩阵乘法问题**：给定$n$个矩阵的链，求完全括号化方案，使得计算乘积所需标量乘法次数最少。

#### 15.2.1 穷举法的复杂度

完全括号化的过程，从计算的角度看，由于每一步的优先级都是确定的，因此最后一步一定是两个完全括号化的部分积相乘，也即括号化过程可以看作是将矩阵链划分为两个任意的部分积后相乘的形式。

以递归公示的形式表达出来为：

$P(n)=\begin{cases}1 &n=1\\\displaystyle\sum_{k=1}^{n-1}P(k)P(n-k) &n\ge 2\end{cases}$

其中，$P(n)$表示$n$个矩阵链可供选择的括号化方案数量。

可以证明，这个递归公式的结果为$\Omega(2^n)$。

#### 15.2.2 动态规划方法

矩阵链乘法可以用动态规划方法进行最优解求解。

### 15.3 动态规划原理

本节讨论何时使用动态规划。

适合应用动态规划方法求解的最优化问题应该具备两个要素：**最优子结构**和**子问题重叠**。

#### 15.3.1 最优子结构

如前文所述，如果一个问题的最优解包含其子问题的最优解，我们就称此问题具有**最优子结构**性质。

可以用子问题的总数和每个子问题需要考察多少种选择这两个因素的乘积来粗略分析动态规划算法的运行时间。

#### 15.3.2 注意事项

考虑有向图的两个典型问题：

- 无权最短路径
- 无权最长路径（简单路径）

无权最短路径具有最优子结构的性质，但是无权最长路径不具有最优子结构的性质。

对于无权最短路径问题，假设存在一条路径为无权最短路径（记为$uv$），则从这条路径中取一点$p$，得到了两条路径$up,pv$，可以证明，这两条路径同样也是这两条路径之间的无权最短路径（可以直接反证）。因此无权最短路径问题具有最优子结构性质。

对于无权最长路径问题，其并不满足最优子结构性质（甚至子问题合并之后都不一定是一个合法解）。事实上，这是一个NP完全问题，目前还没有一个多项式时间的解法。

无权最长路径问题不具有最优子结构的一个显著特征是其**子问题之间是相关的**。如果某个子问题用到了某个点，则相邻的子问题在使用这个点的时候需要考虑简单路径的要求。

#### 15.3.3 重叠子问题

适用动态规划方法求解的最优化问题应该具备的第二个性质是子问题空间必须足够小，即问题的递归算法回反复地求解相同的子问题，而不是一直生成新的子问题。一般而言，子问题的总数是输入规模的多项式函数为好。

如果递归算法反复求解相同的子问题，我们就称最优化问题具有**重叠子问题**。与之相对的，**适合用分治法**求解的问题通常在递归的每一步都生成全新的子问题。

### 15.4 最长公共子序列

生物学上，对比两个碱基串A、B的相似度的时候，其中一个方法是寻找一个碱基串C，这个串的所有碱基既在串A上，也在串B上，且在三个串中出现的顺序相同。可以找的串C的长度越长，则认为两个碱基串越相似。

子序列的形式化定义如下：

给定一个序列$X=<x_1,x_2,...,x_m>$，另一个序列$Z=<z_1,z_2,...,z_n>$，当序列$Z$满足如下条件时称为序列$X$的**子序列**：存在一个严格递增的序列$X$的下标序列$<i_1,i_2,...,i_k>$，满足$x_{i_j}=z_j$。

如果一个序列$Z$同时是序列$A$和序列$B$的子序列，则称序列$Z$是序列$A$和序列$B$的**公共子序列**。

最长公共子序列问题：给定两个序列，求两个序列的最长公共子序列。longest-common-subsequence problem, LCS.

#### 15.4.1 穷举法

找出序列$A$的所有子序列，然后验证该序列是否为$B$的子序列，即为最长公共子序列的穷举解法。对于长度为$n$的序列$A$，其子序列的一共有$2^n$个，也因此穷举法的时间复杂度是指数阶，这对于长序列是不实用的。

#### 15.4.2 是否可以使用动态规划方法

##### 15.4.2.1 最优子结构

LCS问题具有最优子结构。

如果定义序列$X$的前$i$个元素构成的新序列为该序列的**前缀**$X_i$。则最优子结构可以描述为，两个序列的LCS包含了两个序列的前缀的LCS。

可以先假设两个序列$X$,$Y$具有一个LCS为$Z$，通过分别讨论三个序列的最后一个元素的相等关系，得到这个最优子结构的证明。讨论如下：

记$X=<x1,x_2,...,x_m>$，$Y=<y_1,y_2,...,y_n>$为两个序列，$Z=<z_1,z_2,...,z_k>$为$X$和$Y$的任意LCS。

- 如果$x_m=y_n$，则$x_m=y_n=z_k$，且$Z_{k-1}$为$X_{m-1}$和$Y_{n-1}$的一个LCS；
- 否则，如果$x_m\ne z_k$，则$Z为$$X_{m-1}$和$Y$的一个LCS；
- 否则（$y_n\ne z_k$），则$Z$为$X$和$Y_{n-1}$的一个LCS；

三种情况的证明都比较显然，不列举。三种情况都符合最优子结构的性质。

##### 15.4.2.2 递归式

记$c(i,j)$为序列前缀$X_i$和$Y_j$的LCS的长度。根据以上讨论，有以下递归式：

$\displaystyle c[i,j]=\begin{cases}0 &i=0或j=0\\c[i-1,j-1]+1 &x_i=y_j\\max\{c[i-1,j],c[i,j-1]\} &x_i\ne y_j\end{cases}$

##### 15.4.2.3 重叠子问题

以$c[2,3]$为例，在以上递归式中，在最多的情况下（实际上就是LCS的长度为0的情况），我们需要计算$c[2,3],c[2,2],c[2,1],c[2,0],c[1,3],...,c[0,3],c[0,2],c[0,1],c[0,0]$总共$(2+1)\times (3+1)=12$个子问题，也即对于$c[i,j]$，最多存在$(i+1)\times (j+1)=\Theta(ij)$个子问题。

因此，LCS问题也是复合重叠子问题要求的。

##### 15.4.2.4 算法实现

参考代码实现。

### 15.5 最优二叉搜索树

略。

## 第16章 贪心算法

求解最优化问题的算法通常需要经过一系列的步骤，在每个步骤都面临多种选择。对于许多最优化问题，使用动态规划算法来求最优解有些杀鸡用牛刀了，可以使用更简单、更高效的算法。贪心算法就是这样的算法，它在每一步都做出当时看起来最佳的选择。

贪心算法并不保证得到最优解，但对很多问题确实可以求得最优解。

### 16.1 活动选择问题

假定有一个活动的集合$S=\{a_1,a_2,...,a_n\}$，这些活动使用同一个资源，这个资源统一时间只能供一个活动使用。每个活动的时间区间为$[s_i,f_i)$。如果两个活动的时间区间不重叠，则称两个活动是兼容的。活动选择问题即选出最大的兼容活动集（这里的最大，指的是集合的元素最多）。

#### 16.1.1 最优子结构

首先验证活动选择问题具有最优子结构性质，也即某个活动集的最大兼容活动集一定包含了其子集（子问题空间）的最大兼容活动集。这个问题的最优子结构性质是显然的。

#### 16.1.2 递归式

令$S_{ij}$表示在$a_i$结束之后开始，且在$a_j$开始之前结束的那些活动的集合。用$c[i,j]$表示集合$S_{ij}$的最优解的大小。再假设$a_k$是$S_{ij}$的最优解中的一个，则问题被划分为两个子问题，即求$S_{ik}$,$S_{kj}$的最优解。

有$\displaystyle c[i,j]=\begin{cases}0 &S_{ij}=\empty\\\max(c_{ik}+c_{kj}+1) &S_{ij}\not = \empty,a_k\in S_{ij}\end{cases}$

#### 16.1.3 贪心选择

活动选择问题可以使用动态规划的方法求解，但是其同时也满足贪心选择的要求。假设活动已经按结束时间排序，在选择第一个活动时，需要尽可能的将结束时间提前，也即第一个活动一定是$a_1$，选择了之后剩余的活动必须在活动$a_1$结束之后才能开始。记$S_k$为在$a_k$结束后开始的任务集合，此时$S_k$即为需要求解的子问题。

定理：对于任意非空子问题$S_k$，令$a_m$是其中结束时间最早的活动，则$a_m$在$S_k$的某个最大兼容活动子集中。

证明：记$A_k$是$S_k$的一个最大兼容活动子集，$a_j$是其中结束最早的活动。取集合$A_k'=A_k-\{a_j\}+\{a_m\}$（即把$a_j$替换成$a_m$），由于$A_k$中元素互不相交，而$a_m$的结束时间一定不晚于$a_j$，因此$A_k'$中的元素也互不相交。由于$|A_k'|=|A_k|$，即$A_k'$也是一个最大兼容活动子集。而$a_m\in A_k'$，故得证。

#### 16.1.4 算法实现

比较简单，略。

### 16.2 贪心算法原理

