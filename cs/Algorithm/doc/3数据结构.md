
# 第三部分 数据结构

## 第10章 基本数据结构

### 栈和队列

**栈**实现的是一种先进后出的策略；**队列**实现的是一种先进先出的策略。  

### 链表

链表是一种各对象按现行顺序排列的数据结构，链表中对象的顺序是由各个对象里的指针决定的。  

### 有根树

链表的表示进行推广，即一个节点可以通过多个指针指向多个对象，即实现了一个有最大分支数量的有根树。  

对于分支没有限制的有根树，可以通过左孩子，右兄弟的表示方法，转换为一棵二叉树表示。  

## 第11章 散列表

数组可以看作是一种特殊的散列表。  

如果关键字和值的位置一一对应，则就是直接寻址。  
如果关键字和值的位置通过一个散列函数对应，则就是散列表形式。  

### 链接法

通过散列函数来对值的位置进行散列，存在冲突的可能。  

链接法是一种解决冲突的手段。如果出现了冲入，则在冲突位置引入链表进行解决。  

### 除法散列

$h(k)=k \mod C$ ，除数本身就是散列表的容量大小。  
除数应避免一些特定的值，比如如果选择为 $2$ 的 $n$ 次幂，则 $h(k)$ 只会取 $k$ 的低 $n$ 位。  
一般而言，可以考虑一个远离 $2^n$ 的素数。  

### 全域散列

所谓全域散列，即在散列函数的选择上引入随机性。  

### 开放寻址法

与链接法对应，开放寻址法在碰到冲突之后，不是仍然使用原地址，而是在已有空间中按某种策略继续寻找可用位置。  

寻找的策略包括线性探查、二次探查、双重散列。  

线性探查：  
$h(k,i)=[h'(k) + i]\mod m$  
线性探查会引起一次群集。（即长度越长的已占用序列前的空槽被占用的概率越高）  

二次探查：  
$h(k,i)=[h'(k)+c_1i+c_2i^2]\mod m$  
二次探查会引起二次群集。二次群集的群集程度好于一次群集。  

双重散列：  
$h(k,i)=[h'(k)+ih''(k)]\mod m$  
双重散列是比较好的散列方式，但是为了确保所有的位置都能被散列到，要求 $h''(k)$ 和 $m$ 互素（互质，即互相不能整除）。  
一个实现方法是将 $m$ 取为素数，并将 $h''(k)$ 设计为总是返回比 $m$ 小的函数。  

## 第12章 二叉搜索树

构造一棵二叉树，并且始终保持左子节点不大于根节点，右子节点不小于根节点。  

BST：Binary search tree.  

查询：从根节点开始，按大小寻找。  

插入：和查询类似，找出待插入的位置。  

前驱：左子树的最右侧子节点；如果没有左子树，则向上查找第一个向左的双亲节点；如果没有向左的双亲节点，则没有前驱。  

后继：右子树的最左侧子节点；如果没有右子树，则向上查找第一个向右的双亲节点；如果没有向右的双亲节点，则没有后继。  

删除：  
- 如果没有孩子节点，则直接删除。  
- 如果只有一个子节点，则直接用子节点替换被删除的节点。  
- 如果有两个子节点，这里既可以从左子树中找节点来替换，也可以在右子树中找节点来替换。这里以右子树为例。    
  - 如果后继即为右子树，则直接用右子树替换。  
  - 如果后继不为右子树（则一定为右子树的最左侧节点），则先用后继的右节点替换后继，然后用后继来替换被删除的节点。  

代码示例：
src/project/BST

## 第13章 红黑树

红黑树是平衡搜索树中的一种，可以保证在最坏情况下基本动态集合操作的时间复杂度为 $O(\lg n)$ 。  

### 红黑树的来源

注意：红黑树是一种对于 B 树（特殊的如 2-3-4 树）的转换。  
参考：<https://www.cnblogs.com/tiancai/p/9072813.html>  

2-3-4 树操作回顾：

注：所谓 2-3-4 树，也即 4 阶 B 树，是指一个节点可能的子节点数为 2 到 4 个。  
**查找**：和二叉搜索树类似，从根节点按大小逐个递归查找即可。  
**插入**：和二叉搜索树的插入逻辑类似，将节点插入到可列节点的叶节点上。与之不同的是，插入关键字总是插入到一个叶节点上（二叉搜索树是插入到叶节点的左右子节点上）。如果一个叶节点插入后关键字数超过最大个数，则将该叶节点分裂，并将中间的关键字移动到叶节点的双亲节点上。然后递归的对双亲节点进行检查。  
**删除**：删除的情况稍复杂一些：  
- 若被删除的节点不是叶节点，则其一定有右子树。取右子树的最小节点并替换被删除的节点，然后执行删除右子树的最小节点的操作（即删除一个叶节点）。  
- 若被删除的节点是叶节点，则一共有三种情况：  
  - 被删节点的关键字仍足够，则删除完成。  
  - 被删节点的关键字不够，但是其相邻兄弟节点的有可借的关键字，则用被删节点的双亲节点的临近关键字补充被删关键字的位置，然后用相邻节点的相邻关键字补充双亲节点被移除的关键字。  
  - 被删节点的关键字不够，且其相邻兄弟节点也没有可借关键字，则将双亲节点中的对应关键字移动到兄弟节点中。此时双亲节点被移除了一个关键字，则递归对双亲节点进行检查（如果双亲节点的关键字不够，则又考虑从双亲节点的兄弟节点借），直到双亲节点没有出现被删除的情况（少一个元素的情况），或者双亲节点作为根节点被删除（此时根节点替换为被合并后的节点）。  

2-3-4 树存在 2- 、3- 和 4- 三种节点。  

红黑树是一种 2-3-4 树的实现，其主要思路是将 2-3-4 树中的 3- 或 4- 节点利用着色的方式展开为 2- 节点树，展开的方式如下：  
对 3- 节点，将左侧关键字降为右侧元素的左子节点，3- 节点的三个指针分别成为被降为子节点的左侧关键字的左右子树，以及右侧元素的右侧指针。  
对 4- 节点，将左侧和右侧关键字降为中间元素的左子节点和右子节点，将 4- 节点的四个子节点分别分配给被降级为左右两个子节点的子节点。  
降级为子节点的元素染为红色，未降级的元素染为黑色。称未降级的节点为真实节点，降级的节点为扩展节点。  
这样，所有的节点就都是 2- 节点了，只是通过颜色的不同来标记是 2- 节点还是 3- 节点或 4- 节点。  

一些问题：  

- 如何判别节点是真实节点还是扩展节点？  
所有黑色节点一定都是真实节点，所有红色节点一定都是扩展节点。扩展节点从属的真实节点就是其双亲节点。  

### 红黑树的性质

一棵**红黑树**是满足以下性质的**二叉搜索树**：  

1. 每个节点或是红色的，或是黑色的
2. 根节点是黑色的
3. 每个叶节点是黑色的
4. 如果一个节点是红色的，则它的两个子节点都是黑色的
5. 对每个结点，从该节点到其所有后代的简单路径上，均包含相同数目的黑色节点

由红黑树的性质可知，从根节点到所有叶节点的路径上的黑色节点数是相同的，因此记某一条路径上的黑色节点数为**黑高**。  

定理 一棵有 $n$ 个内部节点的红黑树的高度至多为 $2\lg (n+1)$  

使用归纳法证明：  
记节点 $x$ 的黑高为 $bh(x)$ ，假设有 $x$ 对应子树的内部节点数至少为 $2^{bh(x)}-1$ 。  
对叶节点，其黑高为 $0$ ，其有 $0$ 个内部节点，符合假设。  
对某个内部节点，其对应的子树为左子树和右子树的节点总数加 $1$ ，根据假设，即为 $2^{bh(x)-1}-1 + 2^{bh(x)-1} - 1 + 1=2^{bh(x)}-1$ ，也即符合假设。  
$n \ge 2^h-1$ ，也即 $h\le \lg_2(n+1)$  
结论对根节点也成立，因此得证。  

红黑树 5 个性质的理解：  
从 2-3-4 树的角度来理解。  

1. 只需要两种颜色来判别节点的类型。  
2. 由于根节点一定是真实节点，因此根节点一定是黑色节点。  
3. 叶节点用来处理边界条件，叶节点可以视为一个空节点。空节点显然是一个真实节点，因此为黑色。  
4. 由于红色节点的双亲节点是其真实节点，因此红色节点的双亲节点只能是黑色节点。  
5. 由于 2-3-4 树是一棵平衡树，因此所有叶节点的高度是相等的。在将 2-3-4 树转换为红黑树后，对于每个节点，转换后都只有一个黑色节点，也即每个节点涉及的路径中都只有一个黑色节点（或者说，只考虑 2-3-4 树的某一个节点，在转换后产生的所有路径上，都没有新增黑色节点），这样通过递归法就可以证明最终所有路径上的黑色节点的个数是相等的。  

性质的扩展：  
1. 红色节点的双亲节点一定是黑色节点。  

### 红黑树的左右旋

左、右旋  
如果一个节点有右子树，则该节点能进行左旋；如果一个节点有左子树，则该节点能进行右旋。  
左、右旋是对称的操作。  

左旋和右旋，对于 2-3-4 树，也是旋转操作。  

### 插入  

- 插入的节点被着色为红色  
分析：由于被插入的节点一定是插入到 2-3-4 树的某个节点中，也即对应的是一个扩展节点，因此一定是红色的。  

- 插入新的节点后如何维护？  
分析：  
这里我们先直接引入《算法导论》中介绍的操作。  
  1. 按二叉搜索树的插入逻辑，将新插入的节点插入红黑树，并将新插入的节点着色为红色。  
  2. 插入一个新节点只可能破坏规则 2 和 规则 4：  
  - 如果规则 2 被破坏，也即插入的节点就是根节点，则直接将其着色为黑色即可。  
  - 如果规则 4 被破坏，也即插入的节点的双亲节点也是红色节点，  
    现只考虑被插入的节点的父节点是左节点的情况（即新节点的父节点是左节点，或者说定位到的节点是左节点，此时只有两种情况，即新插入的红色节点是一个红色节点的左节点或右节点）  
    - 如果红色节点的上两层黑节点右节点也是红色节点，则将第一个黑节点的左右两个子节点都着色为黑色，并将第一个黑节点着色为红色，然后递归检查这个被着色的节点。  
    - 如果不满足之前的条件，且红色节点是一个右节点，则对该节点及其双亲节点执行左旋。  
    - 如果不满足之前的条件（即插入节点的上两层节点的右节点是叶节点），则将上层节点着为黑色，上两层节点着为红色，然后对上两层节点执行右旋。  
    - 注意：只有这三种情况。  
      也即，或者新插入的节点的上两层节点有右节点；或者上两层节点没有右节点，被插入节点为左节点或者右节点。  

- 对维护过程的理解：从 2-3-4 树的角度出发  
《算法导论》中介绍的维护过程并不是一个容易理解的维护过程，因此我们从 2-3-4 树转化为红黑树的角度出发，来探究为何这样操作。  
1. 插入的节点为红色节点，因此其结果就是在 2-3-4 树的某个叶节点上增加了一个关键字。  
2. 规则 2 被破坏，也即插入的节点是 2-3-4 树的根节点，此时该节点被着色为黑色。  
3. 规则 4 被破坏，也即向一个节点插入的节点位于扩展节点的一侧，从而引起一侧的扩展节点达到了 2 个，这里也同样以左侧为例进行讨论。  
  - 第一种情况，右节点是红节点，左节点是红节点，并且插入了一个红节点，也即总数为 4 个节点。此时，需要从节点中间找出一个关键字，移动到上层节点中，并将剩余的节点按左右成为新的左右节点。对于红黑树而言，其操作就是对节点进行着色。  
  - 第二种情况，右节点不是红节点，左节点是红节点，并且插入了一个红节点，插入的红色节点是右节点。此时总数为 3 个节点，并没有超过最大节点，但是由于红色节点都在黑色节点的左侧，因此需要调整。这里不必直接调整完成，而是可以通过对插入节点的上一层节点执行左旋，从而将情况转换为第三种情况。  
  - 第三种情况，右节点不是红节点，左节点是红节点，并且插入了一个红节点，插入的红色节点是左节点。此时总数为 3 个节点，并没有超过最大节点，但是由于红色节点都在红色节点的左测，因此需要调整。这里可以直接对插入节点的上 2 层节点执行右旋，并调整着色，将下降的节点着色为红色，将上升到上 2 层节点位置的节点着色为黑色。  

注意：这里略去了左旋右旋操作对于 2-3-4 树而言，也是一个基本操作（也即维护了性质）。  

## 第14章 数据结构的扩张

略。