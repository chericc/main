# 算法导论 - 第二部分 排序和顺序统计量

[toc]

**排序**，即对于一个给定的数列，对所有元素进行重排，使得数列中任意左侧的元素不大于右侧的元素。  

**顺序统计量**，即找出 $n$ 个数中第 $i$ 小的数。  

## 2.6 第六章 堆排序

**堆**是一个数组，对应一棵完全二叉树。其中，数组从第一个元素到最后一个元素，依次对应二叉树的根节点和从上往下，从左至右的节点。  

**原理**：构造最大堆，然后循环进行根元素和堆尾部元素交换，并执行堆维护，直到堆中只剩余一个元素。  

堆维护过程：  
对于一个最大堆，如果交换了堆尾元素和根元素，则堆的性质被破坏，此时只需要将根元素逐层下降，每次下降时分别与左右子树的根节点进行比较，并与较大者进行交换。  
堆维护与树的高度有关，因此其时间复杂度为 $O(\lg n)$ 。  

建堆过程：  
建堆可以利用堆维护过程来进行，从下至上，从右至左（左右顺序其实没关系），依次对每一个子树执行堆维护过程，则最终就能得到一个最大堆。  
不失一般性，以一个满树为例，设树高为 $h$ ，则总的时间复杂度为 $h + 2 (h-1) + 2^2(h-2)+...+2^{h-1}\cdot (h-(h-2))=S$ ，可以求得 $S=h+2^h+2^{h-1}$ ，因此有时间复杂度为 $O(n)$ 。  

### 堆排序

仅以树的最下层元素的排序为例，一共 $\lg n$ 个元素，每个元素需要 $O(n)$ 的时间来维护堆，因此总的时间复杂度为 $n\lg n$ 。  

代码示例：  
理解了堆排序的维护过程和建堆过程之后，堆排序并不难理解。  

代码参考：chapter6/heapsort.cpp

### 优先队列

优先队列同样可以利用最大堆来实现。  

取最大元素：  
直接返回根元素即可。  

取最大元素并删除最大元素：  
取得根元素，并将最后一个元素和根元素交换。  
然后执行对维护过程。

扩大某元素：  
找出该元素和其父节点的大者，并将该节点和大者交换。如果
父节点被交换，则继续堆父节点进行检查。  

缩小某元素：  
和堆维护过程一致。  

插入新元素：  
在堆末尾新增一个空元素，并将该元素
缩小或扩大至给定的值。  

代码示例：  
和堆排序类似，略。  

## 2.7 第七章 快速排序

快速排序的核心思想是对给定的一组数，选定一个元素并以此为参考，将元素划分为小于参考的元素和大于参考的元素。  

代码示例：  
chapter6/quicksort.cpp

## 2.8 第八章 线性时间排序

### 决策树模型

通过比较来排序可以被抽象为一个决策树模型，这个决策树的每一个节点表示一次比较，决策树的左右分支表示比较的结果。  
决策树的高度表示了比较的最大次数，决策树的所有叶节点表示所有可能的排序结果。也即每个叶节点对应一个原始的排列。  

由于 $n$ 个元素最多有 $n!$ 个排列，高度为 $h$ 的树最多有 $2^h$ 个叶节点，因此有 $n! < 2^h$ ，也即 $h>\lg_2 n!$ ，也即比较排序有下界 $n\lg n$ 。  

### 计数排序

以待排元素的值作为索引，放置到对应存储空间中，然后从存储空间中按地址顺序找到所有元素，即为计数排序。  

### 基数排序

分别对一个进制数的各个位依次排序，并且使用计数排序排序实现。  

### 桶排序

将浮点数的范围映射为桶，和计数排序类似的方法进行排序。  

## 2.9 第九章 中位数和顺序统计量

### 最小值和最大值

求出最小值或者最大值，最少需要比较 $n$ 次。  

同时求出最小值和最大值，可以将元素划分为 $2$ 个一组，将两个元素先进行比较，则 $2$ 个元素只需要 $3$ 次比较，也即总的比较次数为 $3n/2$ 次。  

### 选择问题

选择问题：  
找出 $n$ 个互异的数中第 $i$ 大的数。  

同找出最大值和最小值一样，选择问题也是一个可以在线性时间内解决的问题。  

使用分治法解决选择问题：  

选定一个元素作为主元，将输入划分为两个部分，若主元恰为第 $i$ 个元素，则直接返回主元；若第 $i$ 个元素在左侧，则对左侧元素继续划分；若第 $i$ 个元素在右侧，则对右侧元素进行划分。  


