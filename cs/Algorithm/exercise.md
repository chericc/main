# Introduction to Algorithms - Third Edition - Exercise

> [CLRS Solutions (walkccc.me)](https://walkccc.me/CLRS/)

## 第一章 算法在计算中的作用

### 1.2-2

假设我们正比较插入排序与归并排序在相同机器上的实现。对规模为$n$的输入，插入排序运行$8n^2$步，而归并排序运行$64n\log_2 n$步。问对哪些$n$值，插入排序优于归并排序？

答：即$8n^2 < 64n\lg n$，化简为$n<8\log_2 n$，取等式，解得$x_1=1.10,x_2=43.56$，也即有规模不超过43时，插入排序优于归并排序。

### 1.2-3

$n$的最小值为何值时，运行时间为$100n^2$的一个算法在相同机器上快于运行时间为$2^n$的另一个算法？

答：即$100n^2<2^n$，取等式，解得$x_1=-0.10,x_2=0.10,x_3=14.32$，也即最小值取15即可。

### 2.1-1

说明**INSERTION-SORT**在数组$A=\{31,41,59,26,41,58\}$上的执行过程。

答：
$$
31,41,59,26,41,58\\\
26,31,41,59,41,58\\\
26,31,41,41,59,58\\\
26,31,41,41,58,59
$$

### 2.1-2

重写过程**INSERTION-SORT**，使之按非升序排序。

答：

原算法的外层循环的值可以理解为每次处理的已排序数组的下一个元素的索引值，内层循环的值已排序数组的最后一个值的索引值，每次处理元素时，是从已排序数组的右端，通过不断交换相邻的值从而将未排序的值插入到正确位置。

更改排序时，只需要将比较方式反向即可。

### 2.1-3

考虑一下查找问题：

输入：$n$个数的一个序列$A=\{a_0,a_1,...a_{n-1}\}$和一个值$v$。

输出：下标$i$使得$v=A[i]$或者当$v$不在$A$中出现时，$v$为特殊值$\text{NIL}$。

写出线性查找的伪代码，它扫描整个序列来查找$v$。使用一个循环不变式来证明你的算法是正确的。确保你的循环不变式满足三条必要的性质。

答：

```c
FIND(A,v)
  i = NIL
  for k = 0 to A.length - 1
    if (A[k] == v)
      i = k
      break
  return i
```

每次循环开始前，子序列$A_m=\{a_0,a_1,...,a_{k-1}\}$不包含$v$，此为循环不变式。

初始化时，$k$为$0$，此时子序列为空集合，循环不变式为真。

循环过程中，假设某一次循环开始前循环不变式为真，此时新处理的元素可能等于$v$，此时循环终止，新处理的元素也可能不等于$v$，此时循环继续，$k$加$1$，由于新加入的元素不为$v$，因此循环不变式仍为真。

循环终止可能在循环过程中因为新处理的元素等于$v$引起，此时下标$i$赋值为$k$，而$k$恰好满足$A[k] == v$，因此符合输出要求。循环终止也可能因为处理完所有元素，此时子序列即为序列$A$，也即整个序列中均不包含$v$，此时$i$为初始值$\text{NIL}$，符合输出要求。

### 2.1-4

考虑把两个$n$位二进制整数加起来的问题，这两个整数分别存储在两个$n$元数组$A$和$B$中。这两个整数的和应按二进制形式存储在一个$(n+1)$元数组$C$中。请给出该问题的形式化描述，并写出伪代码。

答：

算法的形式化描述即给出算法的输入和输出，如下：

输入：有两个数组$A=\{a_1,a_2,...,a_n\}$和$B=\{b_1,b_2,...,b_n\}$，其中的每个元素为$0$或$1$，是整数$a$和$b$的二进制形式；

输出：数组$C=\{c_1,c_2,...,c_{n+1}\}$，其中每个元素为$0$或$1$，是整数$a+b$的二进制形式；

伪代码：

```c
// 为方便表达，二进制从左往右写
carry = 0
for i = 0 to (n-1)
    c = a[i] + b[i] + carry
    if c > 1
        carry = 1
    c = c % 2
c[n] = carry
```

