# 单元测试的艺术（The Art of Unit Testing)

## 1 单元测试基础

### 1.1 逐步定义单元测试

**定义1.0** 一个单元测试是一段代码（通常是一个方法），这段代码调用了另一段代码，然后可以检验某些假设的正确性。如果这些假设是错误的，单元测试就失败了。一个单元可以是一个方法或函数。

被测试的对象称为**被测试系统**（System Under Test, SUT）。

**定义更新1.1** 一个单元测试是一段代码，这段代码调用一个工作单元，并检验该工作单元的一个具体结果。如果关于这个最终结果的假设是错误的，单元测试就失败了。一个单元测试的范围可以小到一个方法，大到多个类。

#### 1.1.1 编写优秀单元测试的重要性

编写差劲的单元测试是没有意义的。如果不加鉴别的胡乱编写单元测试，那还不如不写，至少还能免除日后维护时的麻烦。

#### 1.1.2 我们都写过某种单元测试

当我们用某种方法，确保一段代码工作正常的时候，我们就是在进行单元测试。但是这些测试和优秀的单元测试可能有很大的区别。

### 1.2 优秀单元测试的特性

一个优秀的单元测试应当具有如下特性：

- 它应该是自动化的，可重复执行
- 它应该很容易实现
- 它应该第二天还有意义
- 任何人都应该能一键运行它
- 它应该运行速度很快
- 它的结果应该是稳定的
- 它应该能完全控制被测试的单元
- 它应该是完全隔离的
- 如果它失败了，我们应该很容易发现什么是期待的结果，进而定位问题所在

### 1.3 集成测试

任何测试，如果它运行速度不够快，结果不稳定，或者要用到被测试单元的一个或多个真实依赖物，我就认为它是集成测试。

**定义**：集成测试是对一个工作单元进行的测试，这个测试对被测试的工作单元没有完全的控制，并使用该单元的一个或多个真实依赖物，例如时间、网络、数据库、线程或随机数产生器等。

### 1.4 什么是优秀的单元测试

**定义更新1.2** 一个单元测试是一段自动化的代码，这段代码调用被测试的工作单元，之后对这个单元的最终结果的某些假设进行检验。单元测试几乎都是用单元测试框架编写的。单元测试容易编写，能快速运行。单元测试可靠、可读，并且可维护。只要产品代码不发生变化，单元测试的结果是稳定的。

### 1.5 一个简单的单元测试范例

### 1.6 测试驱动开发

越来越多的人选择在产品代码编写之前写单元测试。这种方法称为**测试优先**或者是**测试驱动开发**（Test-Driven Development, TDD）。

TDD和传统开发不同。首先写一个会失败的测试，然后创建产品代码，并确保这个测试通过，接下来是重构代码或者创建另一个会失败的测试。

### 1.7 成功进行TDD的三种核心技能

- 仅仅做到先编写测试，并不能保证测试是可维护、可读以及可靠的
- 仅仅做到编写的测试可读、可维护，并不能保证你获得先编写测试的各种好处
- 仅仅做到先编写测试，并且测试可读、可维护，并不能保证你得到一个设计完善的系统。

## 2 第一个单元测试

### 2.1 单元测试框架

单元测试框架可以帮助开发人员使用一套一直的API更快地编写测试，自动执行这些测试，轻松查看测试结果。

#### 2.1.1 单元测试框架提供什么

框架提供类库，轻松编写结构化的测试：

- 可以继承的基础类或接口
- 置于代码中，用来标记测试方法的属性
- 提供特殊的断言方法的断言类，用于验证代码

框架提供工具，执行一个或全部单元测试：

- 发现代码中的测试
- 自动运行测试
- 运行期间显示状态
- 可以用命令行自动化

框架运行能提供信息，查看测试运行结果：

- 已运行的测试数目
- 未运行的测试数目
- 失败测试数目
- 失败的测试
- 测试失败的原因
- ASSERT消息
- 失败的代码位置
- 可能包括导致测试失败的异常栈信息

#### 2.1.2 xUnit框架

通常单元测试框架都以它们支持的语言的开头字母加上Unit作为名字，它们统称为xUnit框架。

### 2.2 LogAn项目介绍

LogAn：log and notification

场景：公司有很多内部产品，这些产品都会写日志文件，日志文件存储在一个特定的目录中。日志文件的格式是公司指定的，无法用现有的第三方软件进行解析。项目的任务是实现一个产品，对这些日志文件进行分析，在其中搜索特定情况和事件。找到特定的情况和事件后，这个产品应该通知相关的人员。

### 2.3 NUnit初步

略。

### 2.4 编写第一个测试

略。

### 2.5 使用参数重构测试

不应使用硬编码来实现可能会被重用的测试代码。

### 2.6 更多NUnit属性

#### 2.6.1 setup和teardown

需要注意，使用SetUp越多，测试代码的可读性就越差。因为使用SetUp之后，测试的代码通常就分散了。

### 2.7 测试系统状态的改变而非返回值

**定义** **基于状态的测试**通过检查被测试系统及其协作方在被测试方法执行后行为的改变，判定被测试方法是否正常工作。

## 3 使用存根破除依赖

对于一个简单的测试用例，测试只需要检查对象的返回值，或者一个简单系统里的被测试单元状态。

在一个更为实际的例子中，被测对象依赖另一个对象，并且测试代码不能控制这个依赖的对象返回什么值，也不能控制它的行为。这种情况下可以使用存根。

### 3.1 存根简介

**定义**：一个外部依赖项是系统中的一个对象，被测试代码与这个对象发生交互，但你不能控制这个对象。常见的外部对象包括文件系统、线程、内存以及时间等等。

**定义**：一个存根（stub）是对系统中存在的一个依赖项的可控制的替代物。通过使用存根，你在测试代码时无需直接处理这个依赖项。

关于模拟对象和存根的区别：会对模拟对象断言，而不会对存根进行断言。

### 3.2 发现LogAn中对文件系统的依赖

### 3.3 如何使测试LogAnalyzer变得容易

有什么代码无法测试，就添加一个间接层封装对这段代码的调用，然后在测试中模拟这个间接层的实现。

### 3.4 重构代码以提高可测试性

**定义**：重构（refactoring）是在不改变代码功能的前提下对代码的修改。

**定义**：接缝（seam）是代码中可以插入不同功能的地方，这些功能包括使用存根类，添加一个构造函数参数，添加一个可设置的公共属性，把一个方法改成可以重写的虚拟方法，或者把一个委托外部化成一个参数或属性以便从类的外部复制。代码设计的开闭原则要求：类的功能是开放的，允许对其扩展；而源代码是封闭的，不可直接修改。

#### 3.4.1 抽取接口使底层实现可替换

使用这种技术，你需要把和文件系统打交道的代码分离到一个单独的类中，这样容易识别，以便将来在代码中替换掉对这个类的调用。

接下来，你可以让被测试类和实现未知的接口类打交道，而不是使用具体的类。

#### 3.4.2 依赖注入：在被测试单元中注入一个伪实现

通过基于接口的接缝，你可以在类中注入一个接口的实现，让类的方法使用这种接口实现。

- 在构造函数的层次中得到一个接口，把这个接口保存在一个字段中供以后使用
- 以属性读取或设置的方式得到一个接口，把这个接口保存在一个字段中供以后使用
- 使用一下方法在被测试方法调用之前获得一个接口：
  - 方法的参数（参数注入）
  - 工厂类
  - 本地工厂方法

#### 3.4.3 在构造函数层注入一个伪对象

需要给被测试类添加一个新的构造函数（或者给已有的构造函数添加一个新的参数），传入一个接口类型的对象，然后在被测试类中存储这个对象，供被测对象使用。

##### 3.4.3.1 构造函数注入的警告

使用构造函数注入伪对象可能会带来问题。如果被测试代码需要多个存根才能在没有依赖项的情况下正常工作，加入越来越多的构造函数（或者增加参数）就会变得困难。

一个可能的解决办法是创建一个特殊的类，包含初始化一个类需要的所有值。

##### 3.4.3.2 什么时候应该使用构造函数注入

除非使用IoC容器的框架来创建对象，使用构造函数注入对象会使得测试代码变得笨拙。但是和其他依赖注入的方法相比，在API的可读性和可理解性方面，构造函数注入带来的影响是最小的。

#### 3.4.4 用伪对象模拟异常

略。

#### 3.4.5 用属性get或set注入伪对象

和构造函数注入一样，属性注入也定义了那些依赖项是必须的，哪些是可选的，因此影响到API设计。通过使用属性，实际上是在声明：要操作这种类型，这个依赖项不是必须的。

#### 3.4.6 在方法调用前注入伪对象

前述方法中，伪对象是在测试开始之前，由被测试代码之外的代码设置的。这个方法处理的场景是发起存根请求的对象是被测试代码。

使用工厂类：也即被测对象依赖工厂生产依赖的对象，测试的时候对这个工厂注入存根即可。

**间接的层次**：

第一层：在被测试类中伪造一个成员。需要添加一个构造函数，在构造函数中设置类，从测试代码中设置构造函数参数。这种方法会改变被测试类的语义（产品代码需要使用这个接口），因此尽量避免这种做法。

第二层：在工厂类中伪造一个成员。为工厂类添加一个设置方法，把属性设置成你选择的依赖项。缺点是这种方法需要知道这个工厂什么时候会被使用。

第三层：伪造工厂类。这会使得代码难以理解。

略。

### 3.5 重构技术变种

### 3.6 克服封装问题

面向对象技术的存在是为了限制API的最终用户的行为，使对象模型得到正确的使用，避免误用。在为代码编写单元测试的时候，你给这个对象模型增加了另一个最终用户。

## 4 使用模拟对象进行交互测试

被测试的对象可能不会返回任何结果，或者保存任何状态，但是它有一套复杂的逻辑，需要正确地调用其他对象，而被调用对象不受你的控制，或者不是被测试单元的一部分。

### 4.1 基于值的测试、基于状态的测试和交互测试

基于值的测试验证一个函数的返回值；基于状态的测试改变被测试系统的状态，然后验证其可见的行为变化；交互测试处理的是第三种结果类型：调用第三方对象。

**定义**：**交互测试**是对一个对象如何向其他对象发送消息的测试。如果一个特定的工作单元的最终结果是调用另一个对象，你就需要进行交互测试。

应该优先考虑能否使用前两种类型的测试，因为交互测试会让很多事情变得更复杂。

**定义**：**模拟对象**是系统中的伪对象，它可以验证被测试对象是否按预期的方式调用了这个伪对象，因此导致单元测试通过或是失败。通常每个测试最多有一个模拟对象。

**定义**：伪对象是通用的术语，可以描述一个存根或者模拟对象。一个伪对象究竟是存根还是模拟对象取决于它在当前测试中的使用方式：如果这个伪对象是用来检验一个交互，它就是模拟对象，否则就是存根。

### 4.2 模拟对象和存根的区别

要辨别是否使用了存根，最简单的方法是：存根永远不会导致测试失败；测试会使用模拟对象验证测试是否失败。

存根本身不是被断言的对象，只是被测对象依赖的环境。

模拟对象是被断言的对象，其用来检查各种断言。

### 4.3 手工模拟对象的简单示例

### 4.4 同时使用模拟对象和存根

### 4.5 每个测试一个模拟对象

如果一个测试只测试一件事情，测试中应该最多只有一个模拟对象，所有其他的伪对象都是存根。如果一个测试有多个模拟对象，说明你在测试多个事情，这会导致测试过于复杂或脆弱。

### 4.6 伪对象链：用存根生成模拟对象或其他存根

### 4.7 手工模拟对象和存根的问题

使用手工的模拟对象和存根会出现如下问题：

- 编写模拟对象和存根需要花费时间
- 如果类和接口有许多方法、属性或事件，就很难为它编写存根和模拟对象
- 要保存模拟对象多次调用的状态，你需要在手工伪实现里写许多标准代码
- 如果要验证调用者向一个方法调用传递的所有参数都是正确的，需要写多个断言，非常笨拙
- 难以在其它测试中重用模拟对象和存根代码。

## 5 隔离（模拟）框架

隔离框架（isolation framework），即一个在运行时创建和配置伪对象的可重用类库。这些对象称为动态存根和动态模拟对象。

### 5.1 为什么要使用隔离框架

**定义** 一个隔离框架是一套可编程的API，使用这套API创建伪对象比手工编写容易得多，快得多，而且简洁得多。

隔离框架如果设计得当，可以把开发人员从编写重复代码，进行断言或者模拟对象交互中解放出来。如果设计极为巧妙，隔离框架可以使测试持续很多年，开发人员不需要为每一点小的产品代码改动而回头修复测试代码。

### 5.2 动态生成伪对象

**定义** 动态伪对象是在运行时创建的任何存根或者模拟对象，它的创建不需要手工编写任何代码（硬编码）。

#### 5.2.1 在测试中使用NSubstitute

#### 5.2.2 用动态伪对象替换手工伪对象

