# Computer Systems - A programmer's Perspective - Third Edition

本书作者：Randal E.Bryant, David R.O'Hallaron

本书译者：龚奕利 贺莲

出版社：机械工业出版社

版权声明：本文大量摘录了原书内容，仅供个人学习之用，请勿用作其它用途；

## 第1章 计算机系统漫游

计算机系统是由硬件和系统软件组成的，它们共同工作来运行程序。虽然系统的具体实现方式随着时间不断变化，但是系统内在的概念却没有变化。

```c
#include <stdio.h>

int main()
{
    printf("hello, world\n");
    return 0;
}
```

以上程序为hello程序。我们通过追踪hello程序的声明周期来开始对系统的学习：从它被程序员创建开始，到在系统上运行，输出简单的信息，然后终止。我们将沿着这个程序的生命周期，简要地介绍一些逐步出现的关键概念、专业术语和组成部分。后面的章节将围绕这些内容展开。

### 1.1 信息就是位+上下文

hello程序的生命周期是从一个源程序开始的。源程序实际上就是一个由值0和1组成的位序列，8个位被组织成一组，称为字节。每个字节表示程序中的某些文本字符。

大部分的现代计算机系统都使用ASCII标准来表示文本字符，这种方式实际上就是用一个唯一的单字节大小的整数值来表示每个字符。

hello.c的表示方法说明了一个基本思想：系统中的所有信息，包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法是我们谈到这些数据对象时的上下文。

### 1.2 程序被其它程序翻译成不同的格式

hello程序的声明周期是从一个高级C语言程序开始的，因为这种形式能够被人读懂。然而，为了在系统上运行hello.c文件，每条C语句都必须被其它程序转换为一系列的低级机器语言指令。然后这些指令按照一种称为可执行目标程序的格式打好包，并以二进制磁盘文件的形式被存放起来。目标程序也称为可执行目标文件。

![](assets/1_2_1.svg)

### 1.3 了解编译系统如何工作是大有益处的

对于像hello.c这样简单的程序，我们可以依靠变异系统生成正确有效的机器代码。但是，有一些重要的原因促使程序员必须知道编译系统是如何工作的。

- 优化程序性能。现代编译器都是成熟的工具，通常可以生成很好的代码。作为程序员，我们无须为了写出高效的代码而去了解编译器的内部工作。但是，为了在C程序中做出好的编码选择，我们确实需要了解一些机器代码以及编译器将不同的C语句转化为机器代码的方式。

- 理解衔接时出现的错误。根据我们的经验，一些最令人困扰的程序错误往往都与链接器操作有关，尤其是当你构建大型的软件系统时。

- 避免安全漏洞。多年来，缓冲区溢出错误是造成大多数网络和Internet服务器上安全漏洞的主要原因。存在这些错误是因为很少有程序员能够理解需要限制从不受信任的源接收数据的数量和格式。学习安全编程的第一步就是理解数据和控制信息存储在程序栈上的方式会引起的后果。

### 1.4 处理器读并解释储存在内存中的指令

此刻，hello.c源程序已经被编译系统翻译成了可执行目标文件hello，并被存放在磁盘上。要想在Unix系统上运行该可执行文件，我们将它的文件名输入到称为shell的应用程序中。

shell是一个命令行解释器，它输出一个提示符，等待输入一个命令，然后执行这个命令。

#### 1.4.1 系统的硬件组成

一个典型系统的硬件组织，如下图所示：

![](assets/1_4_1_1.svg)

1. 总线

   贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字（word）。字中的字节数是一个基本的系统参数，各个系统中都不尽相同。现在大多数机器字长哟啊么是4个字节，要么是8个字节。

2. IO设备

   IO设备是系统与外部世界的联系通道。每个IO设备都通过一个控制器或适配器与IO总线相连。控制器与适配器之间的主要区别在于它们之间的封装方式。控制器是IO设备本身或者系统的主印制电路板上的芯片组。而适配器则是一块插在主板插槽上的卡。无论如何，它们的功能都是在IO总线和IO设备之间传递信息。

3. 主存

   主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组动态随机存储器（DRAM）芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。

4. 处理器

   中央处理单元（CPU），简称处理器，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC）。在任何时刻，PC都指向主存中的某条机器语言指令（即含有该条指令的地址）。

   从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。

   寄存器文件是一个小的存储设备，有一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU计算新的数据和地址值。

处理器看上去是它的指令集架构的简单实现，但是实际上现代处理器使用了非常复杂的机制来加速程序的执行。因此，我们将处理器的指令集架构和处理器的为体系结构区分开来：指令集架构描述的是每条机器代码指令的效果，而微体系结构描述的是处理器实际上是如何实现的。

#### 1.4.2 运行hello程序

初始时，shell程序执行它的指令，等待我们输入一个命令。当我们在键盘上输入字符串"./hello"之后，shell程序将字符逐一读入寄存器，再把它存放到内存中。

当我们在键盘上敲回车键时，shell程序就知道我们已经结束了命令的输入。然后shell执行一系列指令来加载可执行的hello文件，这些指令将hello目标文件中的代码和数据从磁盘复制到主存。数据包括最终会被输出的字符串“hello, world\n”。

利用直接存储器存取（DMA）技术，数据可以不通过处理器而直接从磁盘到达主存。

一旦目标文件hello中的代码和数据被加载到主存，处理器就开始执行hello程序的main程序中的机器语言指令。这些指令将“hello, world\n”字符串中的字节从主存复制到寄存器文件中，再从寄存器文件中复制到显示设备，最终显示在屏幕上。

### 1.5 高速缓存至关重要

这个简单的示例揭示了一个重要的问题，即系统话费了大量的时间把信息从一个地方挪到另一个地方。因此系统设计者的一个主要目标就是使这些复制操作尽可能快地完成。

根据机械原理，较大的存储设备要比较小的存储设备运行得慢，而快速设备的造价远高于同类的低速设备。比如，一个典型系统上的磁盘驱动器可能比主存大1000倍，但是对处理器而言，从磁盘驱动器上读取一个字的时间开销要比从主存中读取的开销大1000万倍。类似的，一个典型的寄存器文件只存储几百字节的信息，而主存里可存放几十亿字节。然而，处理器从寄存器文件中读数据比从主存中读取几乎要快100倍。更麻烦的是，随着半导体技术的进步，这种处理器与主存之间的差距还在持续增大。

针对这种处理器与主存之间的差异，系统设计者采用了更小更快的存储设备，称为告诉缓存存储器（cache memory），作为暂时的集结区域，存放处理器近期可能会需要的信息。

![](assets/1_5_1.svg)

位于处理器芯片上的L1高速缓存的容量可以达到数万字节，访问速度几乎和访问寄存器文件一样快。一个容量为数十万到数百万字节的更大的L2缓存通过一条特殊的总线连接到处理器。L1和L2 高速缓存是用一种叫做静态随机访问存储器（SRAM）的硬件技术实现的。比较新的、处理能力更强大的系统甚至有三级高速缓存。

通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。

本书得出的重要结论之一就是，意识到高速缓存存储器存在的应用程序员能够利用高速缓存将程序的性能提高一个数量级。

### 1.6 存储设备形成层次结构

在处理器和一个较大较慢的设备之间插入一个更小更快的存储设备的想法已经成为一个普遍的观念。实际上，每个计算机系统中的存储设备都被组织成了一个存储器层次结构。在这个层次结构中，设备的访问速度越来越慢，容量越来越大，并且每字节的造价也越来越便宜。

### 1.7 操作系统管理硬件

回到hello程序的例子。当shell加载和运行hello程序时，以及hello程序输出自己的信息时，shell和hello程序都没有直接访问键盘、显示器、磁盘或主存。取而代之的是，它们依靠操作系统提供的服务。

操作系统有两个基本的功能：

（1）防止程序被失控的应用程序滥用；

（2）像应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备；

操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。文件是对IO设备的抽象，虚拟内存是对主存和磁盘IO设备的抽象表示，进程则是对处理器、主存和IO设备的抽象表示。

#### 1.7.1 进程

像hello这样的程序在现代系统上运行时，操作系统会提供一种假象，就好像系统上只有这个程序在运行。程序看上去是独占地使用处理器、主存和IO设备。处理器看上去就像在不间断地一条接一条地执行程序中的指令，即改程序的代码和数据是系统内存中唯一的对象。这些假象是通过进程的概念来实现的，进程是计算机科学中最重要和最成功的的概念之一。

进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。而并发运行，则是说一个进程的指令和另一个进程的指令是交错执行的。在大多数系统中，需要运行得进程数是多于可以运行它们的CPU数的。操作系统实现这种交错执行的机制称为上下文切换。

操作系统保持跟踪进程运行所需要的所有状态信息。这种状态，也就是上下文，包括许多信息，比如PC和寄存器文件的当前值，以及主存的内容。在任何一个时刻，单处理器系统都只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文，恢复新进程的上下文，然后将控制权传递到新进程。新进程就会从它上次停止的地方开始。

从一个进程到另一个进程的转换是由操作系统内核管理的。内核是操作系统代码常驻内存的部分。

当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的系统调用指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。

**实现进程这个抽象概念需要低级硬件和操作系统软件之间的紧密合作**。

#### 1.7.2 线程

尽管通常我们认为一个进程只有单一的控制流，但是在现代操作系统中，一个进程实际上可以有多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。

#### 1.7.3 虚拟内存

虚拟内存是一个抽象概念，他为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。

以下为Linux进程的虚拟地址空间。在Linux中，地址空间的高地址区域是保留给操作系统中的代码和数据的，这对所有的进程都是一样的。地址空间的低地址区域存放用户进程定义的代码和数据。

| 地址     | 内容                 |
| -------- | -------------------- |
| 0        |                      |
| 程序开始 | 只读的代码和数据     |
|          | 读/写数据            |
|          | 运行时堆             |
| ...      |                      |
|          | 共享库的内存映射区域 |
| ...      |                      |
|          | 用户栈               |
| 高地址   | 内核虚拟内存         |

每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。

- 程序代码和数据。对所有的进程来说，代码是从同一固定地址开始，紧接着的是和C全局变量对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的。
- 堆。代码和数据区之后紧随着的就是运行时堆。代码和数据区在进程一开始时就被指定了大小，与此不同，当调用像malloc和free这样的C标准库函数时，堆可以在运行时动态地扩展和收缩。
- 共享库。大约在地址空间的中间部分是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域。
- 栈。位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。特别地，每次我们调用一个函数时，栈就会增长，从一个函数返回时，栈就会收缩。
- 内核虚拟内存。地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。

**虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互**，包括对处理器生成的每个地址的硬件翻译。基本思想是把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。

#### 1.7.4 文件

文件就是字节序列，仅此而已。系统中的所有输入输出都是通过使用一小组称为Unix IO的系统函数调用读写文件来实现的。

文件这个简单而精致的概念是非常强大的，因为它向应用程序提供了一个统一的视图，来看待系统中可能含有的所有各式各样的IO设备。

### 1.8 系统之间利用网络通信

现代系统经常通过网络和其它系统连接到一起。从一个单独的系统来看，网络可视为一个IO设备。

### 1.9 重要主题

#### 1.9.1 Amdahl定律

Gene Amdahl，计算领域的早期先锋之一，对提升系统某一部分性能所带来的的效果做出了简单却有见地的观察。这个观察被称为Amdahl定律。

该定律的主要思想是，当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。

若系统执行某应用程序所需要的时间为$T_{old}$，假设系统某个部分所需的执行时间所占比例为$\alpha$，而该部分的提升比例为$k$，则这一部分提升前所需时间为$\alpha T_{old}$，提升后所需时间为$\alpha T_{old}/k$，因此，总的执行时间为
$$
T_{new}=(1-\alpha)T_{old} + \alpha T_{old}/k=T_{old}(1-\alpha + \alpha / k)
$$
由此可得出加速比为
$$
S=T_{old}/T_{new}=\frac{1}{1-\alpha(1-\frac{1}{k})}
$$
因此，若想显著加速整个系统，应首先对系统中占用时间比较长的部分进行优化。

#### 1.9.2 并发和并行

并发（concurrency）指一个同时具有多个活动的系统。并行（parallelism）指的是用并发来使一个系统运行得更快。

（1）线程级并发

构建在进程这个抽象之上，我们能够设计出同时有多个程序执行的系统，这就导致了并发。

（2）指令级并行

在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为指令级并行。

（3）单指令、多数据并行

在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即SIMD并行。

#### 1.9.3 计算机系统中抽象的重要性

抽象的使用是计算机科学中最为重要的概念之一。

## 第2章 信息的表示和处理

### 2.1 信息存储

大多数计算机使用8位的块，或者字节（byte），作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为虚拟内存（virtual memory）。内存的每一个字节都由一个唯一的数字来标识，称为它的地址，所有可能地址的集合就称为虚拟地址空间。

#### 2.1.1 十六进制表示法

一个字节由8位组成，在二进制表示法中，它的值域是${00000000}_{2} - {11111111}_{2}$，如果看成十进制整数，它的值域就是$0_{10} - 255_{10}$。两种表示方法用来描述位模式都不是非常方便。替代的方法是，以16位基数，或者叫做十六进制数，来表示。用十六进制书写，一个字节的值域为$00_{16} - \text{FF}_{16}$。

#### 2.1.2 字数据大小

每台计算机都有一个字长（word size），指明指针数据的标称大小（nominal size）。因为虚拟地址是以这样一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。

#### 2.1.3 寻址和字节顺序

对于跨越多字节的程序对象，我们必须建立两个规则：这个对象的地址是什么，以及在内存中如何排列这些字节。在几乎所有机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用的字节中最小的地址。

一个对象的字节的排列表示有两个通用的规则。某些机器选择在内存中按照从最低有效字节到最高有效字节的顺序存储对象，这种最低有效位在最前面的方式，称为小端法。另一些机器按照从最高有效字节到最低有效字节的顺序存储，即最高有效字节在最前面的方式，称为大端法。

对于程序员而言，字节顺序在几种场景下是不可忽略的，包括：

（1）不同类型的机器之间传输二进制数据。这里的一个解决办法是约定将传输的字节序统一为同一个字节序。

（2）反汇编。如代码`int a = 0x12345678`，其x86-64环境下的反汇编代码为`   8:   c7 45 fc 78 56 34 12    movl   $0x12345678,-0x4(%rbp)`，注意到代码的二进制表示中，整形数是以小端形式存储的。

（3）规避正常类型系统的程序。比如，C语言中的强制类型转换。

#### 2.1.4 表示字符串

C语言中的字符串被编码为一个以null字符结尾的字符数组。每个字符都由某个标准编码来表示，最常见的是ASCII字符码。

#### 2.1.5 表示代码

不同的机器类型使用不同的且不兼容的指令和编码方式。即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。

计算机系统的一个基本概念是，从机器的角度来看，程序仅仅只是字节序列。机器没有关于原始程序的任何信息，除了可能有些用来帮助调试的辅助表之外。

#### 2.1.6 布尔代数简介

二进制值是极速三级编码、存储和操作信息的核心，所以围绕数值0和1的研究已经演化出了丰富的数学只是体系。这起源于1850年前后的乔治·布尔（George Boole, 1815-1864）的工作，因此也称为布尔代数。布尔注意到，通过将逻辑值真和假编码为二进制值1和0，能够设计出一种代数，以研究逻辑推理的基本原则。

后来创立信息论领域的Claude Shannon首先建立了布尔代数和数字逻辑之间的联系。他在1937年的硕士论文中表明了布尔代数可以用来设计和分析机电继电器网络。

#### 2.1.7 C语言中的位级运算

C语言的一个很有用的特性就是它支持按位布尔运算。事实上，布尔运算中使用的符号和C语言使用的符号是相同的。

#### 2.1.8 C语言中的逻辑运算

C语言提供了一组逻辑运算符`||`、`&&`、`！`，分别对应于命题逻辑中的OR、AND和NOT运算。逻辑运算很容易和位级运算相混淆，但是它们的功能是完全不同的。逻辑运算中，所有非0的参数均表示TRUE，参数0表示FALSE。

#### 2.1.9 C语言中的移位运算

注意，对于C语言中移位运算，左移总是在右侧补0，右移时，机器支持两种形式的右移：逻辑右移和算术右移。逻辑右移总是在左侧补0，算术右移则在左端补最高有效位的值。

### 2.2 整数表示

#### 2.2.1 整型数据类型

C语言支持多种整型数据类型：表示有限范围内的整数。

#### 2.2.2 无符号数的编码

假设有一个整数数据类型有$\omega$位。我们可以把位向量写成$\overrightarrow{x}$，表示整个向量，或者写成$x_{\omega - 1},x_{\omega - 2},..., x_0$，表示向量中的每一位。把$\overrightarrow{x}$看做一个二进制表示的数，就获得了$\overrightarrow{x}$的无符号表示。在这个编码中，每个位$x_{i}$都取值为$0$或$1$，后一种取值意味着数值$2^i$应为数字值的一部分。我们用一个函数$B2U_{\omega}$（表示Binary to Unsigned的缩写，长度为$\omega$）来表示：

**原理**：无符号数编码的定义

对向量$\overrightarrow{x}=[x_{\omega - 1},x_{\omega - 2},...,x_0]$，$\displaystyle B2U_{\omega}(\overrightarrow{x})\doteq \sum_{i=0}^{\omega-1}x_i2^i$

在这个等式中，符号“$\doteq$”表示左边被定义为等于右边。函数$B2U_\omega$将一个长度为$\omega$的$0$、$1$串映射到非负整数。

**值域**：$\omega$位所能表示的最小值为$0$，最大值为$\displaystyle UMax_{\omega} \doteq \sum_{i=0}^{\omega - 1}2^i = 2^{\omega} - 1$。

**原理**：无符号数编码的唯一性

函数$B2U_{\omega}$是一个双射（思考：如何证明？？？）。

#### 2.2.3 补码编码

最常见的有符号数的计算机表示方式就是补码形式。在这个定义中，将字的最高有效位解释为负权。用函数$B2T_{\omega}$（Binary to Two's-complement，长度为$\omega$）来表示。

**原理**：补码编码的定义

对向量$\overrightarrow{x}=[x_{\omega-1},x_{\omega - 2},...,x_0]$：$\displaystyle B2T{\omega}(\overrightarrow{x})\doteq -x_{\omega -1}2^{\omega -1}+\sum_{i=0}^{\omega -2}x_i2^i$

最高有效位$x_{\omega - 1}$也称为符号位，它的“权重”位$-2^{\omega - 1}$，是无符号表示中权重的负数。符号位被设置为$1$时，表示值为负，而当设置为$0$时，值为非负。

上述函数中，第二部分可以看作是一个总位数为$\omega - 1$的无符号数编码映射，其值域为$[0,2^{\omega}-1]$，第一部分在最高有效位为$1$时，可以看作是一个负方向大小为$2^{\omega - 1}$的偏移，即负方向的值域为$-2^{\omega - 1},$。--------

**值域**：当最高有效位为$1$而其他位全为$0$时，具有最小值$$--------
