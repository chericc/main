# Advanced Programming in the UNIX Environment - Third Edition

## 第1章 UNIX基础知识

### 1.1 引言

本书集中阐述不同版本的UNIX操作系统所提供的服务。

### 1.2 UNIX体系结构

从严格意义上说，可将操作系统定义为一种软件，它控制计算机硬件资源，提供程序运行环境。我们通常将这种软件称为内核。

从广义上说，操作系统包括了内核和一些其它软件，包括系统实用程序、应用程序、shell以及公用函数库等。

### 1.3 登陆

#### 1.3.1 登陆名

用户在登陆UNIX系统时，先键入登陆名，然后键入口令。系统在其口令文件（/etc/passwd )中查看登陆名。

#### 1.3.2 shell

用户登陆后，系统通常先显示一些系统信息，然后用户就可以向shell程序键入命令。shell是一个命令行解释器，它读取用户输入，然后执行命令。

### 1.4 文件和目录

#### 1.4.1 文件系统

UNIX文件系统是目录和文件的一种层次结构，所有东西的起点是称为根的目录，这个目录的名称是一个字符“/”。

#### 1.4.2 文件名

目录中的各个名字称为文件名。只有斜线和空字符不能出现在文件名中，斜线用来分隔构成路径名的各文件名，空字符则用来终止一个路径名。

#### 1.4.3 路径名

由斜线分隔的一个或多个文件名组成的序列构成路径名，以斜线开头的称为绝对路径名，否则称为相对路径名。相对路径名只想相对于当前目录的文件。

#### 1.4.4 工作目录

每个进程都有一个工作目录，有时称其为当前工作目录。所有相对路径名都从工作目录开始解释。进程可以用chdir函数更改其工作目录。

#### 1.4.5 起始目录

登陆时，工作目录设置为起始目录（home directory），该起始目录从口令文件中相应用户的登陆项中取得。

### 1.5 输入和输出

#### 1.5.1 文件描述符

文件描述符通常是一个小的非负整数，内核用以标识一个特定进程正在访问的文件。

#### 1.5.2 标准输入、标准输出和标准错误

按惯例，每当运行一个新程序，所有的shell都为其打开3个文件描述符，即标准输入、标准输出以及标准错误。如果不做特殊处理，这三个描述符都链接向终端。

#### 1.5.3 不带缓冲的IO

略

#### 1.5.4 标准IO

略

### 1.6 程序和进程

#### 1.6.1 程序

程序是一个存储在磁盘上某个目录中的可执行文件。内核使用exec函数将程序读入内存，并执行程序。

#### 1.6.2 进程和进程ID

程序的执行实例被称为进程。UNIX系统确保每个进程都有一个唯一的数字标识符，称为进程ID，进程ID总是一个非负整数。

#### 1.6.3 进程控制

有3个用户进程控制的函数：fork、exec和waitpid。

#### 1.6.4 线程和线程ID

和进程相同，线程也用ID标识。但是，线程ID只在它所属的进程内起作用。

控制线程和函数与控制进程的函数类似，但另有一套。线程模型是在进程模型建立很久之后才被引入UNIX系统中的，然而这两种模型之间存在复杂的交互。

### 1.7 出错处理

当UNIX系统函数出错时，通常会返回一个负值，而且整型变量errno通常被设置为具有特定信息的值。而有些函数对于出错则使用另外一种约定而不是返回负值。

### 1.8  用户标识

#### 1.8.1 用户ID

口令文件登录项中的用户ID是一个数值，它向系统标识各个不同的用户。

#### 1.8.2 组ID

口令文件登录项也包括用户的组ID，它是一个数值。一般来说，在口令文件中有多个登录项具有相同的组ID。

组文件将组名映射为 数值的组ID。组文件通常是`/etc/group` 。

#### 1.8.3 附属组ID

除了在口令文件中对一个登录名指定一个组ID外，大多数UNIX系统版本还允许一个用户属于另外一些组。登录时，读文件`/etc/group`，寻找列有该 用户作为其成员的前16个记录项就可以得到给该用户 的附属组ID。

### 1.9  信号 

信号用于通知 进程发生了某种情况。例如，若某一进程执行除法操作，其除数为0，则将名为`SIGPIPE`的信号发送给该进程。

### 1.10 时间值

### 1.11 系统调用和库函数

所有的操作系统都提供多种服务的入口点，由此程序向内核请求服务。各种版本的UNIX实现都提供良好定义、数量有限、直接进入内核的入口点，这些入口点被称为系统调用。

UNIX所使用的技术是 为每个系统调用在标准C库中设置一个具有同样名字的函数。用户进程用标准C调用序列来调用这些函数，然后，函数有用系统所要求的技术调用相应的内核服务。例如，函数可将一个或多个C参数送入通用寄存器，然后执行某个产生软中断进入内核的机器指令。

从实现者的角度来看，系统调用和库函数之间有根本的区别，但从用户的角度来看，其区别并不重要。

## 第2章 UNIX标准及其实现

略

## 第3章 文件I/O

### 3.10 文件共享

UNIX系统支持在 不同进程间共享打开文件。

> 以下说明是概念性的，与特定实现可能匹配，也可能不匹配。

内核使用3种数据结构表示打开文件，它们之间的关系决定了在文件共享方面一个进程对另一个进程可能产生的影响。

（1）每个进程在进程表中都有一个记录项，记录项中包含一张打开文件描述符表，可将其视为一个 矢量，每个描述符占用一项一项。与每个文件描述符相关联的是：

- 文件描述符标志（`close_on_exec`）
- 指向一个文件表项的指针

（2）内核为所有打开文件维持一张文件表。每个文件表包含：

- 文件状态标志（读、写、添写、同步和非阻塞等）
- 当前文件偏移量
- 指向该文件v节点表项的指针

（3）每个打开文件都有一个v节点结构。v节点包含了文件类型和对此文件进行各种操作的函数指针。对于大多数文件，v节点还包含了该文件的i节点。例如，i节点包含了文件的所有者、文件长度、指向文件实际数据块在磁盘上所在位置的指针等。

> Linux没有使用v节点，而是使用了通用i节点接口。虽然两者实现上有所不同，但是在概念上是一样的。

注意，文件表项和v节点表项是多对一的关系，进程表项和文件表项也是多对一的关系。如果两个进程同时打开一个文件，则分别有两个进程表项和文件表项，但是只有一个v节点表项。

两个进程打开同一个文件的情况举例如下：

- 完成write之后，文件表项中的偏移量即会增加写入的字节数。如果偏移量超出了文件长度，则i节点中的当前文件长度设置为当给钱文件偏移量。
- 如果用`O_APPEND`标志打开一个文件，则这个标志会被设置到文件表项中。每次对这个文件执行写操作时，当前偏移量会首先设置为i节点表项中的文件长度。也即，不论有几个进程打开了这个文件，每次写操作总是会写到文件末尾。
- `lseek`只修改文件表项的当前文件偏移量。

在`dup`或`fork`时，就会出现多个进程表项指向一个文件表项的情况。

### 3.11 原子操作

#### 3.11.1 追加到一个文件

如果先调用seek再调用写来实现写到文件末尾的功能，则当多个进程同时操作同一个时就会出现问题。如果设置了`O_APPEND`标志，则内核在每次写操作之前，都将进程的当前偏移量设置到文件的尾端处，于是在每次写操作之前就不用调用`lseek`。

#### 3.11.2 函数`pread`和`pwrite`

`pread`和`pwrite`相当于先`seek`然后读或写。其主要特点是

- 调用不会被中断
- 不更新当前文件偏移量

#### 3.11.3 创建一个文件

如果在打开文件之前先检查文件是否存在，则可能出现创建文件时这个文件已经被其他进程创建了的情况，此时另一个进程写入的数据会被擦除。`O_CREAT`使得文件不存在时就创建，避免了这个问题。

### 3.12 函数`dup`和`dup2`

这些函数返回的新文件描述符与参数`fd`共享同一个文件表项。

### 3.13 函数`sync`、`fsync`和`fdatasync`

`sync`只是将所有修改过的块缓冲区排入写队列，然后就返回。它并不等待实际写磁盘操作结束（注：Linux上的实现是等待写入结束）。

`fsync`函数只对由文件描述符指定的文件起作用，并且等待磁盘操作结束才返回。`fsync`可用于数据库这样的应用程序。

`fdatasync`类似于`fsync`，但它只影响文件的数据部分。而除数据外，`fsync`还会同步更新文件的属性。

### 3.14 函数`fcntl`

函数`fcntl`可以改变已经打开的文件的属性。

### 3.15 函数`ioctl`

`ioctl`函数一直是I/O操作的杂物箱。不能用本章中其他函数表示的I/O操作通常都能用`ioctl`表示。终端I/O是使用`ioctl`最多的地方。

每个设备驱动程序都可以定义它自己专用的一组`ioctl`命令系统则为不同种类的设备提供通用的`ioctl`命令。

### 3.16 `/dev/fd`

较新的系统都提供名为`/dev/fd`的目录，打开其中的文件等效于复制描述符。

`/dev/fd`文件主要由shell使用，它允许使用路径名作为调用参数的程序，能用处理路径名的相同方式处理标准输入和输出。

## 第4章 文件和目录

### 4.5 文件访问权限

所有文件类型都有访问权限。

每个文件有9个访问权限位。组合为`[用户，组，其他][读、写、执行]`。

术语用户指的是文件所有者，

- 第一个规则是，我们用名字打开任一类型的文件时，对该名字中包含的每一个目录，包括它可能隐含的当前目录都应具有执行权限。

  例如，为了打开路径`/usr/include/stdio.h`，需要对`/`、`/usr`、`/usr/include`具有执行权限。然后，需要对文件本身具有适当权限，这取决于以何种方式打开它。如果当前目录是`usr/stdio`，那么需要对当前目录具有执行权限。也即打开`stdio.h`和`./stdio.h`作用相同。

- 为了在一个目录中创建创建一个新文件，必须对该目录具有写权限和执行权限。
- 为了删除一个现有文件，必须对包含该文件的目录具有写权限和执行权限，对该文件本身则不必有读写权限。

进程每次打开、创建或删除一个文件时，内核就进行文件访问权限测试。这种测试可能涉及文件的所有者（用户ID、组ID）、进程的有效ID（有效用户ID、有效组ID）以及进程的附属ID。

内核进行的测试具体如下：

- 若进程的有效用户ID是0，则允许访问。这给予了超级用户对整个文件系统进行处理的最充分的自由。
- 若进程的有效用户ID等于文件的所有者ID，切适当的访问权限位被设置，则允许访问，否则拒绝访问。
- 若进程的有效组ID或进程的附属组ID之一等于文件的组ID，那么如果组适当的访问权限位被设置，则允许访问，否则拒绝访问。
- 若其他用户适当的访问权限位被设置，则允许访问，否则拒绝访问。

### 4.6 新文件和目录的所有权

新文件的用户ID设置为进程的有效用户ID。关于组ID，有两种可能的方式：

1. 新文件的组ID是进程的组ID；
2. 新文件的组ID是它所在的目录的组ID；

### 4.10 粘着位

`S_ISVTX`位有一段有趣的历史。在UNIX尚未使用请求分页式技术的早期版本中，`S_ISVTX`位被称为粘着位（sticky bit）。如果一个可执行程序文件的这一位被设置了，那么当该程序第一次被执行，在其终止时，程序正文部分的一个副本仍被保存在交换区。这使得下次执行该程序时能较快地将其装载入内存。其原因是：通常的UNIX文件系统中，文件的各数据块很可能是随机存放的，相比较而言，交换区是被作为一个连续文件来处理的。现今较新的UNIX系统大多数都配置了虚拟存储系统以及快速文件系统，所以不再需要使用这种技术。

现今的系统扩展了粘着位的使用范围，Single UNIX Specification允许针对目录设置粘着位。如果对一个目录设置了粘着位，只有对该目录具有写权限的用户并且满足下列条件之一，才能删除或者重命名该目录下的文件：

- 拥有此文件
- 拥有此目录
- 是超级用户

目录`/tmp`和`/var/tmp`是设置粘着位的典型候选者。任何用户都可以在这两个目录中创建文件，任一用户对这两个目录的权限通常都是读、写、执行。但是用户不应能删除或重命名其他人的文件，为此在这两个目录的文件模式中都设置了粘着位。

### 4.14 文件系统

UFS是以Berkeley快速文件系统为基础的，本节讨论该文件系统。

我们可以把一个磁盘分成一个或多个分区，每个分区可以包含一个文件系统。i节点是固定长度的记录项，它包含有关文件的大部分信息。

- 每个i节点中都有一个链接计数，其值是指向该i节点的目录项数。只有当链接计数减少至0时，才可删除该文件。这就是为什么删除一个目录项（指文件）的函数被称为`unlink`而不是`delete`的原因。这种链接类型称为硬链接。
- 另外一种链接类型是符号链接。符号链接文件的内容包含了该符号链接所指向的文件的名字。该i节点中的文件系统类型是`S_IFLNK`，于是系统知道这是一个符号链接。
- i节点包含了文件有关的所有信息：文件类型、文件访问权限位、文件长度和指向文件数据块的指针等。stat结构中大多数信息都取自i节点，除了文件名和i节点编号存储在目录项中。

### 4.19 文件的时间

对每个文件维护3各时间字段，如下：

| 字段      | 说明                    | 例子            | ls选项  |
| --------- | ----------------------- | --------------- | ------- |
| `st_atim` | 文件数据的最后访问时间  | `read`          | `-u`    |
| `st_mtim` | 文件数据的最后修改时间  | `write`         | default |
| `st_ctim` | i节点状态的最后更改时间 | `chmod`,`chown` | `-c`    |

注意`st_mtim`和`st_ctim`的区别。有很多操作只会影响i节点，而不会更改文件的实际内容。因此需要单独记录i节点的更改时间。

系统并不维护对一个i节点的最后一次访问的时间，所以`access`和`stat`函数并不更改这三个时间中的任一个。

### 4.20 读目录

对某个目录有访问权限的任一用户都可以读该目录，但是，为了防止文件系统产生混乱，只有内核才能写目录。

目录的实际格式依赖于UNIX系统实现和文件系统的设计。

### 4.24 设备特殊文件

- 每个文件系统所在的存储设备都由其主、次设备号表示。设备号所用的数据类型是基本系统数据类型`dev_t`。主设备号标识设备驱动程序，有时编码为与其通信的外设板；次设备号标识特定的子设备。同一磁盘驱动器上的各文件系统通常具有相同的主设备号，但是次设备号不同。

## 第5章 标准I/O库

### 5.1 引言

标准I/O库是由Dennis Rirchiez在1975年左右编写的。它是Make Lesk编写的可移植I/O库的主要修改版本。令人惊讶的是，35年来，几乎没有对标准I/O库进行修改。

### 5.2 流和`FILE`对象

标准I/O文件流可用于单字节或多字节字符集。流的定向（stream's orientation）决定了所读、写的字符是单字节还是多字节的。当一个流最初被创建时，它并没有被定向。但若在一个未定向的流上使用一个多字节函数，则该流的定向会被设置为宽定向。

只有两个函数可以改变流的定向，`freopen`清除一个流的定向，`fwide`函数可用于设置流的定向。

### 5.4 缓冲

标准I/O库提供了以下3中类型的缓冲：

- 全缓冲。在这种情况下，在填满标准I/O缓冲区之后才进行实际I/O操作。在一个流上执行第一次I/O操作时，相关函数通常调用`malloc`获得所需要的缓冲区。
- 行缓冲。在这种情况下，当在输入和输出中遇到换行符时，标准I/O库执行操作。
- 不带缓冲。标准错误流`stderr`通常是不带缓冲的。

可以调用`setbuf`和`setvbuf`调整缓冲的类型。

### 5.7 行I/O

可以使用`fgets`执行每次一行的I/O。

### 5.14 内存流

内存流的某些特征使其更适合字符串操作。

有3个函数可用于内存流的创建：

```c
FILE *fmemopen(void *restrict buf, size_t size, const char *restrict type);
FILE *open_memstream(char** bufp, size_t *sizep);
FILE *open_wmemstream(wchar** bufp, size_t *sizep);
```

### 5.15 标准I/O的替代软件

标准I/O库并不完善。

其中一个不足之处是效率不高，通常需要复制两次数据，一次是在内核和缓冲区之间，一次是在缓冲区和用户缓存之间。

也有一些库更关注内存，比如uClibc。

## 第6章 系统数据文件和信息

## 第7章 进程环境

### 7.2 `main`函数

当内核执行C程序时，在调用`main`前，先调用一个特殊的启动例程。可执行程序文件将此启动例程指定为程序的起始地址——这是由链接器设置的。启动例程从内核取得命令行参数和环境变量值，然后为调用`main`做好安排。

### 7.5 环境表

每个程序都接收到一张环境表。与参数表一样，环境表也是一个字符指针数组。全局变量`environ`则包含了该指针数组的地址：

```c
extern char **environ;
```

一个打印环境表的程序如下：

```c
#include <stdio.h>
extern char **environ;
int main()
{
	char **pev = environ;
	while (*pev != nullptr)
	{
		printf("%s\n", *pev);
		++pev;
	}
	return 0;
}
```

### 7.6 C程序的存储空间布局

历史沿袭至今，C程序一直由下列几部分组成：

- 正文段。这是由CPU执行的机器指令部分。通常，正文段是可共享的，所以即使是频繁执行的程序，在存储器中也只需要一个副本。另外，正文段常常是只读的，以防止程序由于意外而修改其指令。
- 初始化数据段。通常将此段称为数据段，它包含了程序中需要明确地覆初值的变量。
- 未初始化数据段。通常将此段称为BSS段，这一名称来源于早期汇编程序的一个操作符，意思是block started by symbol。在程序开始执行之前，内核将此段中的数据初始化为0或空指针。
- 栈。自动变量以及每次函数调用时所需保存的信息都存放在此段中。
- 堆。通常在堆中进行动态存储分配。由于历史上形成的惯例，堆位于初始化数据段和栈之间。

其中，正文段、初始化数据段由exec从程序文件中读入，未初始化的数据段（BSS）由exec初始化为0。也因此，BSS段并不占用可执行文件空间。

size程序可用于分析程序的各个段的大小。

## 第8章 进程控制

### 8.3 函数`fork`

一个现有的进程可以通过调用fork函数创建一个新进程。

由`fork`创建的进程称为子进程。`fork`函数被调用一次，但返回两次。两次返回的区别是，子进程的返回值是0，父进程的返回值是新创建的子进程的ID。子进程可以调用`getppid`获得父进程的ID。（为0的ID总是由内核交换进程使用，因此子进程的ID不可能是0）

注意，子进程会共享父进程打开的文件，这表现在他们共享一套文件表。

### 8.10 函数`exec`

用`fork`函数创建新的子进程后，子进程往往要调用一种`exec`函数以执行另一个程序。

有7种不同的`exec`函数可供使用，它们常常被统称为`exec`函数，我们可以使用这7个函数中的任一个。

```c
execl();
execv();
execle();
execve();
execlp();
execvp();
fexecve();
```

关于函数命名，有：

`p`表示传入的是文件名（不是路径名）；

- 当文件名是绝对路径名时，就作为路径名处理；
- 否则在`PATH`中搜索文件名；如果找到了一个不是链接器产生的文件，则尝试按shell脚本处理；

`l`表示传入参数列表；

`v`表示传入参数向量；

`e`表示环境变量通过参数指定；

最后一个通过传入文件描述符创建；

在很多UNIX实现中，只有`execve`是系统调用，另外6个是库函数。

### 8.11 更改用户ID和更改组ID

在UNIX系统中，特权以及访问控制是基于用户ID和组ID的。

一般而言，在设计应用时，我们总是试图使用最小特权模型。依照此模型，程序应当只具有完成给定任务的最小特权。这降低了由恶意用户试图欺骗程序以未预料的方式使用特权造成的安全性风险。

### 8.12 解释器文件

所有现今的UNIX系统都支持解释器文件。这种文件是文本文件，其起始行的形式是：

```bash
#! pathname [optional-argument]
```

一个常见的写法为：

```bash
#! /bin/sh
```

对这种文件的识别通常是由内核作为exec系统调用处理的一部分来完成的。

### 8.13 函数`system`

`system`函数原型如下：

```c
#include <stdlib.h>
int system(const char *cmdstring);
```

因为`system`其实现中调用了`fork`、`exec`和`waitpid`，因此有3种返回值：

（1）`fork`失败或者`waitpid`返回除`EINTR`之外的出错，则`system`返回-1，并且设置`errno`以指示错误类型。

（2）如果`exec`失败，则其返回值如同shell执行了`exit(127)`一样。

（3）否则，如果三个函数都成功，那么`system`的返回值是shell的终止状态。

`system`的一个安全风险是，调用者的权限在被调用的子程序中被保存了下来。设想调用者具有root权限，则子程序将会获得这个权限，从而产生了权限泄漏。注：这里权限继承表现在有效用户ID的继承。

### 8.14 进程会计

大多数UNIX系统提供了一个选项以进行进程会计处理。启用该选项后，每当进程结束时，内核就写一个会计记录。典型的会计记录包含总量较小的二进制数据，一般包括命令名、所使用的CPU时间总量、用户ID和组ID、启动时间等。

一个至今没有说明的函数（`acct`）启用和禁用进程会计。唯一使用这一函数的命令是`accton`命令。超级用户执行一个带路径名参数的`accton`命令启用会计处理。

### 8.16 进程调度

UNIX系统历史上对进程提供的只是基于调度优先级的粗粒度的控制。调度策略和调度优先级是内核确定的。进程可以通过调整nice值选择以更低的优先级运行。只有特权进程允许提高调度权限。

进程可以通过`nice`函数获取或更改它的nice值。`getpriority`和`setpriority`可为进程、进程组、特定用户ID的所有进程查询和设置进程优先级。

### 8.17 进程时间

可以调用`times`函数获得进程自己的墙上时钟时间、用户CPU时间、系统CPU时间。

## 第9章 进程关系

上一章已经了解到进程之间具有关系。首先，每个进程有一个符进程。当子进程终止时，父进程的到通知并能取得子进程的退出状态。
