# Advanced Programming in the UNIX Environment - Third Edition

## 第1章 UNIX基础知识

### 1.1 引言

本书集中阐述不同版本的UNIX操作系统所提供的服务。

### 1.2 UNIX体系结构

从严格意义上说，可将操作系统定义为一种软件，它控制计算机硬件资源，提供程序运行环境。我们通常将这种软件称为内核。

从广义上说，操作系统包括了内核和一些其它软件，包括系统实用程序、应用程序、shell以及公用函数库等。

### 1.3 登陆

#### 1.3.1 登陆名

用户在登陆UNIX系统时，先键入登陆名，然后键入口令。系统在其口令文件（/etc/passwd )中查看登陆名。

#### 1.3.2 shell

用户登陆后，系统通常先显示一些系统信息，然后用户就可以向shell程序键入命令。shell是一个命令行解释器，它读取用户输入，然后执行命令。

### 1.4 文件和目录

#### 1.4.1 文件系统

UNIX文件系统是目录和文件的一种层次结构，所有东西的起点是称为根的目录，这个目录的名称是一个字符“/”。

#### 1.4.2 文件名

目录中的各个名字称为文件名。只有斜线和空字符不能出现在文件名中，斜线用来分隔构成路径名的各文件名，空字符则用来终止一个路径名。

#### 1.4.3 路径名

由斜线分隔的一个或多个文件名组成的序列构成路径名，以斜线开头的称为绝对路径名，否则称为相对路径名。相对路径名只想相对于当前目录的文件。

#### 1.4.4 工作目录

每个进程都有一个工作目录，有时称其为当前工作目录。所有相对路径名都从工作目录开始解释。进程可以用chdir函数更改其工作目录。

#### 1.4.5 起始目录

登陆时，工作目录设置为起始目录（home directory），该起始目录从口令文件中相应用户的登陆项中取得。

### 1.5 输入和输出

#### 1.5.1 文件描述符

文件描述符通常是一个小的非负整数，内核用以标识一个特定进程正在访问的文件。

#### 1.5.2 标准输入、标准输出和标准错误

按惯例，每当运行一个新程序，所有的shell都为其打开3个文件描述符，即标准输入、标准输出以及标准错误。如果不做特殊处理，这三个描述符都链接向终端。

#### 1.5.3 不带缓冲的IO

略

#### 1.5.4 标准IO

略

### 1.6 程序和进程

#### 1.6.1 程序

程序是一个存储在磁盘上某个目录中的可执行文件。内核使用exec函数将程序读入内存，并执行程序。

#### 1.6.2 进程和进程ID

程序的执行实例被称为进程。UNIX系统确保每个进程都有一个唯一的数字标识符，称为进程ID，进程ID总是一个非负整数。

#### 1.6.3 进程控制

有3个用户进程控制的函数：fork、exec和waitpid。

#### 1.6.4 线程和线程ID

和进程相同，线程也用ID标识。但是，线程ID只在它所属的进程内起作用。

控制线程和函数与控制进程的函数类似，但另有一套。线程模型是在进程模型建立很久之后才被引入UNIX系统中的，然而这两种模型之间存在复杂的交互。

### 1.7 出错处理

当UNIX系统函数出错时，通常会返回一个负值，而且整型变量errno通常被设置为具有特定信息的值。而有些函数对于出错则使用另外一种约定而不是返回负值。

### 1.8  用户标识

#### 1.8.1 用户ID

口令文件登录项中的用户ID是一个数值，它向系统标识各个不同的用户。

#### 1.8.2 组ID

口令文件登录项也包括用户的组ID，它是一个数值。一般来说，在口令文件中有多个登录项具有相同的组ID。

组文件将组名映射为 数值的组ID。组文件通常是`/etc/group` 。

#### 1.8.3 附属组ID

除了在口令文件中对一个登录名指定一个组ID外，大多数UNIX系统版本还允许一个用户属于另外一些组。登录时，读文件`/etc/group`，寻找列有该 用户作为其成员的前16个记录项就可以得到给该用户 的附属组ID。

### 1.9  信号 

信号用于通知 进程发生了某种情况。例如，若某一进程执行除法操作，其除数为0，则将名为`SIGPIPE`的信号发送给该进程。

### 1.10 时间值

### 1.11 系统调用和库函数

所有的操作系统都提供多种服务的入口点，由此程序向内核请求服务。各种版本的UNIX实现都提供良好定义、数量有限、直接进入内核的入口点，这些入口点被称为系统调用。

UNIX所使用的技术是 为每个系统调用在标准C库中设置一个具有同样名字的函数。用户进程用标准C调用序列来调用这些函数，然后，函数有用系统所要求的技术调用相应的内核服务。例如，函数可将一个或多个C参数送入通用寄存器，然后执行某个产生软中断进入内核的机器指令。

从实现者的角度来看，系统调用和库函数之间有根本的区别，但从用户的角度来看，其区别并不重要。

## 第2章 UNIX标准及其实现

略

## 第3章 文件I/O

### 3.10 文件共享

UNIX系统支持在 不同进程间共享打开文件。

> 以下说明是概念性的，与特定实现可能匹配，也可能不匹配。

内核使用3种数据结构表示打开文件，它们之间的关系决定了在文件共享方面一个进程对另一个进程可能产生的影响。

（1）每个进程在进程表中都有一个记录项，记录项中包含一张打开文件描述符表，可将其视为一个 矢量，每个描述符占用一项一项。与每个文件描述符相关联的是：

- 文件描述符标志（`close_on_exec`）
- 指向一个文件表项的指针

（2）内核为所有打开文件维持一张文件表。每个文件表包含：

- 文件状态标志（读、写、添写、同步和非阻塞等）
- 当前文件偏移量
- 指向该文件v节点表项的指针

（3）每个打开文件都有一个v节点结构。v节点包含了文件类型和对此文件进行各种操作的函数指针。对于大多数文件，v节点还包含了该文件的i节点。例如，i节点包含了文件的所有者、文件长度、指向文件实际数据块在磁盘上所在位置的指针等。

> Linux没有使用v节点，而是使用了通用i节点接口。虽然两者实现上有所不同，但是在概念上是一样的。

注意，文件表项和v节点表项是多对一的关系，进程表项和文件表项也是多对一的关系。如果两个进程同时打开一个文件，则分别有两个进程表项和文件表项，但是只有一个v节点表项。

两个进程打开同一个文件的情况举例如下：

- 完成write之后，文件表项中的偏移量即会增加写入的字节数。如果偏移量超出了文件长度，则i节点中的当前文件长度设置为当给钱文件偏移量。
- 如果用`O_APPEND`标志打开一个文件，则这个标志会被设置到文件表项中。每次对这个文件执行写操作时，当前偏移量会首先设置为i节点表项中的文件长度。也即，不论有几个进程打开了这个文件，每次写操作总是会写到文件末尾。
- `lseek`只修改文件表项的当前文件偏移量。

在`dup`或`fork`时，就会出现多个进程表项指向一个文件表项的情况。

### 3.11 原子操作

#### 3.11.1 追加到一个文件

如果先调用seek再调用写来实现写到文件末尾的功能，则当多个进程同时操作同一个时就会出现问题。如果设置了`O_APPEND`标志，则内核在每次写操作之前，都将进程的当前偏移量设置到文件的尾端处，于是在每次写操作之前就不用调用`lseek`。

#### 3.11.2 函数`pread`和`pwrite`

`pread`和`pwrite`相当于先`seek`然后读或写。其主要特点是

- 调用不会被中断
- 不更新当前文件偏移量

#### 3.11.3 创建一个文件

如果在打开文件之前先检查文件是否存在，则可能出现创建文件时这个文件已经被其他进程创建了的情况，此时另一个进程写入的数据会被擦除。`O_CREAT`使得文件不存在时就创建，避免了这个问题。

### 3.12 函数`dup`和`dup2`

